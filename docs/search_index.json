[["index.html", "がんばらないデータ加工 ーRによる繰り返し作業入門ー 前編 はじめに 本書の特徴 注意事項など 特別付録について", " がんばらないデータ加工 ーRによる繰り返し作業入門ー 前編 やわらかクジラ はじめに 本書はデータ加工での面倒な作業をRでらくらく実行できるようになるための基礎知識を紹介する目的で執筆しました。が，本書は核心の部分に入る前の準備段階まででとどまっています。タイトルに「前編」とあるのはその理由によります。 本当は，複数データセットの複数変数をいっぺんに加工，集計，可視化ドヤァ！みたいなのをまとめたかったのです。今後の「後編」（もしかしたら「中編」も）をお楽しみにということで・・・ タイトルから手に取っていただいた方，ごめんなさい。 本当は 最初から 本書『がんばらないデータ加工 ーRによる繰り返し作業入門ー』を書こうと思ったのは拙既刊書『Rで読むExcelファイル』と同じく，「RとRStudioを使いたい！と思う人がもっと増えればいいのに」という願いから 既刊書では省いたRのモダンな方法を使ったデータ加工の基本関数の紹介と，自身の使用経験から実務的な使い方を紹介する入門書 データをきれいにする過程（例：前処理、データクリーニング、データクレンジング、データラングリングなど） ヘルプに書いてある例では分かりにくいことが時々あるので， 初学者に では，巷に多く出ている入門的な解説と何が違うのか？ 本書の特徴 これまでの解説で不足していること 便利な関数や基本的な使い方の解説は多いが，データ加工の実務上知りたいコード例が豊富なわけではない 同じ作業を大量の変数についてくり返し実行したい時のやり方の解説は少ない まずはよくあるモダンなRのデータラングリング解説 本書の強みは，くり返し同じ作業する部分を効率化したコードを併せて解説する点 自分の学習経験から，そのコード例が知りたかったんだ！という実用的な方法を収集 「がんばらない」とは，単純作業のくり返しに無駄なエネルギーを注がなくてよいようにすること まず基本の書き方を解説した後に，__【効率化】__でより効率的にコードを書く解説を行う *【効率化】のタグが本書の核心になる。手作業の繰り返しをなるべく避けることが目指すべき点だからである。 冗長だが【別解】を示すことで様々な関数の働きを理解でき，手持ちの武器が増えデータ加工の幅が広がる 本書の内容は、githubレポジトリの ですべて公開しています。コードやサンプルデータはこちらのレポジトリをダウンロードしてお試しください。pdf版が読みたい方は、以下のページで無料で入手可能です。自力でできる方は、Build Bookでも作成できます。 技術書典マーケットの販売ページ 想定読者 色々なExcelファイルを読み込んで分析する機会があるのであれば、全くRのことを知らない方から、少しRの経験があるけど複数のファイルを一度に読みこんだことはないというレベルの方ぐらいまでが対象となるでしょう。 本書の到達目標は、RでのExcelファイルの読み書きレベルをある程度高める、という所に定めました。その先は是非好きなように可視化なり解析なり進めていただければと思います。とはいえ、そこでお好きなように！と言われても路頭に迷う方もいるかもしれないので、データの内容把握に関して、要約値や欠損値の一覧、簡単な可視化、相関の一覧についても少しだけ解説しました。その一助として、特別付録として本書と並行してまとめた、可視化のためのggplot2の辞書（特別付録について参照）もあります。 なお、「前篇」とつけたのは，効率化を目指すコードにさらに踏み入っていく場合，リストの理解やpurrrパッケージの使い方などを丁寧に説明する必要があるため， 各セクションの概要 まず2章では、RStudioでファイルを読み書きする際に、最低限知っておいた方がよい知識について解説しておきます。とっつきにくいかもしれませんが、知っておいてよかったと後になって実感する類のものなので、使って慣れていきましょう。 4章は本書のメインであるExcelファイルの読み込みについて解説します。一つのファイルの読み込みから、複数シート、複数ファイルの読み込みまで、様々なシーンに対応しました。また、読みこんだファイルを一つのデータフレーム1にまとめる方法についても触れています。 章はExcelファイルの保存についてです。ここでも、一つのファイルの保存から、複数ファイルの保存まで解説します。ここまでの内容が理解できれば、大量ファイルの読み書きにまつわる単純な繰り返し作業とはさよならできるでしょう。 章は関連知識としてcsvファイルの読み込みと保存について解説します。windowsユーザーは文字コードの違いによる文字化けというつらみと対峙することになり、初学者はここで脱落していくことが多いのではないかと思います。そのために、サバイバルスキルとして知っておくことが有用だと思い書いておきました。自分が相当苦しんだので… 章は、読み込んだファイルの特徴をざっと把握する方法について解説しました。ここまでやれば、（きれいなデータであれば！）きっとデータ解析に入っていくことができるでしょう。 執筆環境 本書はbookdownにて執筆しました 2 RおよびRStudio、パッケージのバージョン R version 3.6.1 RStudio version 1.3.1073 readxl version 1.3.1 tidyverse version 1.3.0 注意事項など 本書の内容はすべてwindows環境を想定しています。 この本に書いてある内容は、筆者が学習したことをまとめているものにすぎないため、正常な動作の保証はできません。使用する際は、自己責任でお願いします。 特別付録について 本書の執筆に先駆けて、順序が違う気がしますがまず付録の作成からはじめました。特別付録は以下でアクセス可能なオンライン付録となります。 ggplot2の辞書 https://izunyan.github.io/practice_ggplot2/ Twitterで応援してもらったら項目が増えていく仕様にしているので、もっと読みたい方はこちらのツイートに何らかのレスポンスください！ 変数（列）とオブザベーション（行）が碁盤の目のようになった集まりの形のデータ。Excelであれば通常1行目に列名が入り、2行目以降が個別のデータを表す。データ解析において便利で分かりやすいため、本書ではデータフレームの形で説明していく↩︎ https://bookdown.org/↩︎ "],["premise.html", "1 前提知識 1.1 本書に出てくるコード部分の見方 1.2 プロジェクト 1.3 パッケージ 1.4 関数 1.5 オブジェクト 1.6 データフレーム 1.7 %&gt;% （パイプ演算子）", " 1 前提知識 ここに出てくる用語は初学者にとってなじみがないものばかりかもしれないが，Rでデータ加工をらくらくできるようになるためには避けて通れない 1.1 本書に出てくるコード部分の見方 グレーの背景部分はRのコードが書いてあり，その下の##で始まる部分は出力結果を表す 1 + 1 ## [1] 2 ここでは1 + 1がコード部分で，## [1] 2が出力結果部分 [1]というのは，その次にくる値（ここでは１つしかないが）が何番目にあるかを示している たとえば，1から50までの数値を出力してみる コロン:で最初と最後の値をつなぐことで連番を表現できる 1:50 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 コード部分に#で始まる文章がある場合は，コメントを表す。ここは実行されないので説明のために書かれる # *（アスタリスク） は掛け算であることを示す 2 * 3 # ここにもコメントを入れられる ## [1] 6 1.2 プロジェクト データを加工して解析する際に、1つのフォルダ（サブフォルダも含む）の中に関連するデータやコードなどをまとめておき、そのフォルダを プロジェクト と設定する これにより、ファイルの読み書きの際の場所指定をいちいち意識しないで作業できるようになる 詳しくは拙書の解説参照 1.3 パッケージ 様々な関数やデータなどがまとまっていて，読み込むと色々なことができる 逆にいえば読み込まないと便利な作業ができないことが多い 例：library(tidyverse)またはrequire(tidyverse) のように書くことで読み込める パッケージを読み込まなくても，パッケージ名::関数名( )でパッケージ内の関数が使える どのパッケージの関数か明示するのにも便利なので，本書では多用する 以下，例えば「パッケージdplyrの関数select( )」はdplyr::select( )と表現する 1.4 関数 適切な値や変数などを指定すれば，データの処理や計算，統計解析など様々な処理を簡単に実行してくれる データ加工の技術は，色々な便利関数をどの場面でどうやって使うかにつきる 例えばmean( )などのように関数名( )で出てくるので，( )で囲まれてる所を見たらほぼ関数だと思えばよさそう ( )の中に入る値を 引数 （ひきすう）と呼ぶ 引数は,でつないで追加していき，これによって実行したい処理のカスタマイズが可能 + 関数の( )の最初の位置に来るものを 第一引数 という 1.4.1 例 1.4.1.1 複数のものを1つにする: c( ) ベクトル を作る（複数のものを1つにする）ための関数 ベクトルと聞くと数学苦手だった人はいやな記憶を思い出すかもしれないが，Rではとにかく「複数のものを１つにしたもの」と理解しておけば何となると思う c()は慣れてる人は当たり前に使っているので，初学者にとって理解しとくとよい最重要関数と思われる ベクトルは，後に解説するデータフレームでの列単位のデータを扱う際にも有用 c(1,2,3) ## [1] 1 2 3 c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # &quot; &quot;で囲まれる値は文字を表す ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 複数あるように見えるが実は1つのベクトルになっている例 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 1.4.1.2 平均値：mean( ) 引数にベクトルを入れることで平均値を計算する mean(c(1,2,3)) ## [1] 2 # 欠損値（NA）があると結果がNA mean(c(1, NA, 3)) ## [1] NA # 引数にna.rm = TRUEを追加すると結果が出る。基本的に実務上は常につけておいたほうがよい mean(c(1, NA, 3), na.rm = TRUE) ## [1] 2 1.5 オブジェクト 計算の結果や，複数の数値や文字など（他にも色々）を1つの文字列に格納することができ，その後のコードで活用できる &lt;-の矢印の先にあるのがオブジェクト。RStudioではショートカットalt + -で出せる(MacはOption + -) この後説明するデータフレームもオブジェクトに入れられる データの少ないミニデータを作る時や，計算結果を格納するときに多用 1.5.1 例 res &lt;- 1 + 1 res ## [1] 2 res2 &lt;- c(1, 2:4, 5) res2 ## [1] 1 2 3 4 5 res3 &lt;- c(&quot;a&quot;, &quot;b&quot;) res3 ## [1] &quot;a&quot; &quot;b&quot; rm(res, res2, res3) 1.6 データフレーム 変数（列）とケースまたはオブザベーション（行）が碁盤の目のようになった集まりの形のデータ。Excelで表現するのであれば通常1行目に列名が入り、2行目以降が個別のデータを表す形 データ解析において便利で分かりやすいため、本書ではデータフレームの形で説明していく Rのモダンな方法では，データの加工や統計処理のプロセスをデータフレームの形で返すことが多い オブジェクトに格納することで，別のデータフレームを作れる 列単位で取り出すとベクトルになる 本書では，データフレームの中でも表示に便利なtibble形式を使う 本書では紙面の都合上，表示行数をしぼっているが，任意の行数を見たいときはprint( )関数で出力ごとに設定 1.6.1 本書で使う主なデータ 1.6.1.1 ペンギンデータ palmerpenguinsパッケージのpenguinsデータ（CC0） 1.7 %&gt;% （パイプ演算子） コードを読みやすくするための便利な機能を持つ演算子。初めてみた人は全然わからないと思うが，この本を読んでコードを書きはじめてみたらこれなしではいられなくなるくらいお世話になると思う。 主に使用が想定される場面でざっくりいうと，「このデータフレームに対して%&gt;%の後にある関数を適用する」という機能 具体的な使用法は??で解説 RStudioのショートカットはCtrl + Shift + M(MacはCmd + Shift + M)。たぶん，RStudio以外でもこのショートカット押してしまうぐらい中毒性がある R version 4.1からは|&gt;が大体同じ機能を持つ演算子して実装されたので，特にパッケージの読み込みをせずに使えるようになった。こちらを使う説明も今後増えていくと思われる ショートカットで出るパイプを|&gt;に切り替えたい場合は，RStudioのTools &gt; Global Options &gt; Code &gt; Editing &gt; use native pipe operatorにチェックを入れる 現時点ではデータフレームを第一引数へ渡す形式でない関数の場合（回帰分析のlm( )など），工夫が必要な場合があるようなので，本書では%&gt;%を使用 "],["select.html", "2 変数（列）を選ぶ：select( ) 2.1 データ読み込み 2.2 基本 2.3 変数の指定に便利なヘルパー関数 2.4 特定の変数を選ばない（落とす） 2.5 変数を並び変える 2.6 変数名を変更する 2.7 関心のある変数名を取得する 2.8 【応用編】複数データフレームで同時にselect", " 2 変数（列）を選ぶ：select( ) dplyr:select( ) tidyな世界では「列名 = 変数名」 変数が多い時に関心ある変数に限定したデータにしたい 関心ある変数の名前を取得したい 後々出てくる繰り返し作業で便利なヘルパー関数 2.1 データ読み込み データの指定を簡単にするために，penguinsデータをdfと読み込む library(tidyverse) # パッケージが入ってなければ下記実行 # install.packages(&quot;palmerpenguins&quot;) df &lt;- palmerpenguins::penguins # データの表示 df ## # A tibble: 344 x 8 ## species island bill_length_mm bill_depth_mm flipper_length_~ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 読み込みの様々な方法については拙書『Rで読むExcelファイル』参照 2.2 基本 select( )の中に関心のある変数名を,をつけて並べる 変数は1つからOK df %&gt;% select(bill_length_mm, bill_depth_mm) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows 新しいデータフレームを作りたい場合は&lt;-を使って新しいオブジェクトに格納する df2 &lt;- df %&gt;% select(bill_length_mm) df2 ## # A tibble: 344 x 1 ## bill_length_mm ## &lt;dbl&gt; ## 1 39.1 ## 2 39.5 ## 3 40.3 ## # ... with 341 more rows 2.2.1 【補足】%&gt;% の意味 1.7で説明したパイプ演算子の実例を解説する 2.2.2 範囲指定 関心ある変数が指定された範囲に含まれていれば:でつなげて取得できる 変数の連番をまとめて指定する時などに便利（例 変数1:変数100） df %&gt;% select(bill_length_mm:flipper_length_mm) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 範囲に加えて追加の変数を追加できる 飛び飛びの変数群を選びたいときに有用 df %&gt;% select(bill_length_mm:flipper_length_mm, sex) ## # A tibble: 344 x 4 ## bill_length_mm bill_depth_mm flipper_length_mm sex ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; ## 1 39.1 18.7 181 male ## 2 39.5 17.4 186 female ## 3 40.3 18 195 female ## # ... with 341 more rows 2.2.3 中身が文字でも動く 変数名が\" \"で囲われていると，Rでは文字(character)だと認識される df %&gt;% select(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows これは効率化を図りたいときに重要な特徴 select( )の中にたくさんの変数名を並べるより，事前に指定しておきベクトルとして代入した方が読みやすい あらかじめ作成したベクトルとして代入するときは，all_of( )で囲む必要がある 様々なコード例でこの事前指定が多用されるので慣れるとよい # あらかじめオブジェクト（ここではvars）に引数を格納して後で使えるようにする vars &lt;- c(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;) df %&gt;% select(all_of(vars)) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows ここでvarsは文字ベクトル（vector）のオブジェクトとなっている all_of( )の中に文字ベクトルを指定することで，それぞれの中身を変数名として認識する 以前使われていたone_ofは現在は非推奨 2.3 変数の指定に便利なヘルパー関数 selection helperと呼ばれるtidyselectパッケージの関数群 selectの所で解説されることが多いが，後から出てくるacross()と併せた活用場面が多いため，なじんでおくと後から楽になる 2.3.1 変数名の最初の文字列 billから始まる変数を選ぶ df %&gt;% select(starts_with(&quot;bill&quot;)) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows 2.3.2 変数名の最後の文字列 _mmで終わる変数を選ぶ mmだけだと他にも含まれる場合が出てくるので，_も含めた方が安全 df %&gt;% select(ends_with(&quot;_mm&quot;)) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 2.3.3 変数名のどこかに含まれる文字列 指定した文字列を含んだ変数名を対象とする df %&gt;% select(contains(&quot;length&quot;)) ## # A tibble: 344 x 2 ## bill_length_mm flipper_length_mm ## &lt;dbl&gt; &lt;int&gt; ## 1 39.1 181 ## 2 39.5 186 ## 3 40.3 195 ## # ... with 341 more rows 2.3.3.1 変数名のどこかに含まれる文字列：その2 文字列で 正規表現 が使えるため柔軟な指定が可能 ここでは，“length”または”depth”を含む変数名を対象 |が「または」を意味する df %&gt;% select(matches(&quot;length|depth&quot;)) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 2.3.4 上記の組み合わせ 2.3.4.1 かつ それぞれの条件を両方満たす df %&gt;% select(starts_with(&quot;bill&quot;) &amp; contains(&quot;length&quot;)) ## # A tibble: 344 x 1 ## bill_length_mm ## &lt;dbl&gt; ## 1 39.1 ## 2 39.5 ## 3 40.3 ## # ... with 341 more rows 2.3.4.2 または それぞれの条件をいずれか満たす df %&gt;% select(starts_with(&quot;bill&quot;) | contains(&quot;length&quot;)) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 2.3.5 数値範囲 num_range ## function (prefix, range, width = NULL, vars = NULL) ## { ## vars &lt;- vars %||% peek_vars(fn = &quot;num_range&quot;) ## if (!is_null(width)) { ## range &lt;- sprintf(paste0(&quot;%0&quot;, width, &quot;d&quot;), range) ## } ## match_vars(paste0(prefix, range), vars) ## } ## &lt;bytecode: 0x000000001c8c1170&gt; ## &lt;environment: namespace:tidyselect&gt; 2.4 特定の変数を選ばない（落とす） 変数名の前に!をつける df %&gt;% select(!species) ## # A tibble: 344 x 7 ## island bill_length_mm bill_depth_mm flipper_length_mm ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Torgersen 39.1 18.7 181 ## 2 Torgersen 39.5 17.4 186 ## 3 Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 複数列を落としたい場合は，!c( )の中に対象の列名を含める df %&gt;% select(!c(bill_length_mm:flipper_length_mm, sex)) ## # A tibble: 344 x 4 ## species island body_mass_g year ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 3750 2007 ## 2 Adelie Torgersen 3800 2007 ## 3 Adelie Torgersen 3250 2007 ## # ... with 341 more rows 2.5 変数を並び変える 2.6 変数名を変更する 2.7 関心のある変数名を取得する データ分析の段階では，関心のある変数名を選択して，それらを代入する作業が頻出 変数名手打ちだと時間もかかるしミスもあるので，効率化のために必ずおさえておきたい技術 2.7.1 全ての変数名 df %&gt;% names() ## [1] &quot;species&quot; &quot;island&quot; &quot;bill_length_mm&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; &quot;year&quot; 2.7.2 選択した変数名を取得 ベクトル bill_vars &lt;- df %&gt;% select(starts_with(&quot;bill&quot;)) %&gt;% names() bill_vars ## [1] &quot;bill_length_mm&quot; &quot;bill_depth_mm&quot; 2.7.3 コピペに便利な形式に出力 ,で区切られた形式で出てくればそのままselect()に入れられるのに…と思った方のための便利関数dput() df %&gt;% select(starts_with(&quot;b&quot;)) %&gt;% # bから始まる変数名 names() %&gt;% dput() ## c(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, &quot;body_mass_g&quot;) \" \"すらもいらない，という時は，新しくr script(アイコンNew Fileまたはctrl + shift + n)開いて，dput()の出力を貼り付けてすべて置換する方法も 2.8 【応用編】複数データフレームで同時にselect 2.8.1 複数データフレームで同じようにselect 2.8.2 複数データフレームで別々にselect https://izunyan.github.io/practice_bfi/#13_%E3%82%AF%E3%83%AD%E3%83%B3%E3%83%90%E3%83%83%E3%82%AF%E3%81%AE%E3%82%A2%E3%83%AB%E3%83%95%E3%82%A1 "],["rename.html", "3 変数名を変更する：rename( ) 3.1 基本 3.2 同じ語を共通の語で置き換える 3.3 同じ語を削除する 3.4 同じ接尾辞をつける 3.5 同", " 3 変数名を変更する：rename( ) パッケージdplyrの関数rename() tidyな世界では「列名 = 変数名」 変数が多い時に関心ある変数に限定したデータにしたい 関心ある変数の名前を取得したい 3.1 基本 変更したい変数名を new = old の順に入力する ここではbill_length_mmをblmmに変更してみる 複数の変数名を変更する場合は，rename()の中に,でつなげていく たくさんある場合に一つ一つ書いていくのは大変 df %&gt;% names() ## [1] &quot;species&quot; &quot;island&quot; &quot;bill_length_mm&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; &quot;year&quot; df %&gt;% rename(blmm = bill_length_mm) ## # A tibble: 344 x 8 ## species island blmm bill_depth_mm flipper_length_~ body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torge~ 39.1 18.7 181 3750 ## 2 Adelie Torge~ 39.5 17.4 186 3800 ## 3 Adelie Torge~ 40.3 18 195 3250 ## # ... with 341 more rows, and 2 more variables: sex &lt;fct&gt;, ## # year &lt;int&gt; # 複数をrenameする場合 df %&gt;% rename(blmm = bill_length_mm, bdmm = bill_depth_mm) ## # A tibble: 344 x 8 ## species island blmm bdmm flipper_length_~ body_mass_g sex ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 Adelie Torgers~ 39.1 18.7 181 3750 male ## 2 Adelie Torgers~ 39.5 17.4 186 3800 fema~ ## 3 Adelie Torgers~ 40.3 18 195 3250 fema~ ## # ... with 341 more rows, and 1 more variable: year &lt;int&gt; 複数変数を扱うときはrename_with()が便利。以下はそれを用いた例を示していく 3.2 同じ語を共通の語で置き換える 変数名の”bill”の部分を日本語の”くちばし”に変更していく まずは基本の知識でできる方法 df %&gt;% rename(くちばし_length_mm = bill_length_mm, くちばし_depth_mm = bill_depth_mm) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.2.1 【効率化】str_replace()で一括変換(1) rename_with( )は，まず適用したい関数を示し，そのあとに該当する変数を選ぶ 適用したい関数の中にある.の部分に，その後選ぶ変数が入っていく 語の置き換えはstringr::str_replace()を使う df %&gt;% rename_with(~str_replace(., &quot;bill&quot;, &quot;くちばし&quot;), starts_with(&quot;bill&quot;)) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.2.1.1 【別解】 selectのように単にc( )の中に変数を指定していくだけでも動く df %&gt;% rename_with(~str_replace(., &quot;bill&quot;, &quot;くちばし&quot;), c(bill_length_mm, bill_depth_mm)) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.3 同じ語を削除する “_mm”を取り除きたい場合，それを削除した変数名を指定すればよいが，たくさんあると大変 df %&gt;% rename(bill_length = bill_length_mm, bill_depth = bill_depth_mm, flipper_length = flipper_length_mm) ## # A tibble: 344 x 8 ## species island bill_length bill_depth flipper_length ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 3.3.1 【効率化】str_replace()で一括変換（2） str_replace()で変換先に空白\"\"を指定すると削除できる df %&gt;% rename_with(~str_replace(., &quot;_mm&quot;, &quot;&quot;), ends_with(&quot;mm&quot;)) ## # A tibble: 344 x 8 ## species island bill_length bill_depth flipper_length ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 3.3.1.1 【別解】 stringr::str_remove()の方が直接的 df %&gt;% rename_with(~str_remove(., &quot;_mm&quot;), ends_with(&quot;mm&quot;)) ## # A tibble: 344 x 8 ## species island bill_length bill_depth flipper_length ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 3.4 同じ接尾辞をつける 変数yearで2007年のみのデータに限定し，くちばし（bill）と翼（flipper）の変数名の末に”_2007”をつける renameの中に全部書いていけばできれば数が多いと大変 df %&gt;% filter(year == 2007) %&gt;% select(bill_length_mm:flipper_length_mm, year) %&gt;% rename(bill_length_mm_2007 = bill_length_mm, bill_depth_mm_2007 = bill_depth_mm, flipper_length_mm_2007 = flipper_length_mm) ## # A tibble: 110 x 4 ## bill_length_mm_2007 bill_depth_mm_2007 flipper_length_mm~ year ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 39.1 18.7 181 2007 ## 2 39.5 17.4 186 2007 ## 3 40.3 18 195 2007 ## # ... with 107 more rows 3.4.1 【効率化】str_c()で一括指定 適用したい関数の中にある.の部分に，その後選ぶ変数が入っていく stringr::str_c()で指定した語をくっつける ここでは変数year以外なので，!をつけることで変数を指定できる df %&gt;% filter(year == 2007) %&gt;% select(bill_length_mm:flipper_length_mm, year) %&gt;% rename_with(~str_c(., &quot;_2007&quot;), !year) ## # A tibble: 110 x 4 ## bill_length_mm_2007 bill_depth_mm_2007 flipper_length_mm~ year ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 39.1 18.7 181 2007 ## 2 39.5 17.4 186 2007 ## 3 40.3 18 195 2007 ## # ... with 107 more rows 3.4.1.1 【別解】 df %&gt;% filter(year == 2007) %&gt;% rename_with(~str_c(., &quot;_2007&quot;), matches(&quot;bill|flipper&quot;)) ## # A tibble: 110 x 8 ## species island bill_length_mm_2007 bill_depth_mm_2007 ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 107 more rows, and 4 more variables: ## # flipper_length_mm_2007 &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.5 同 df %&gt;% rename(くちばし_length_mm = bill_length_mm, くちばし_depth_mm = bill_depth_mm) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.5.1 【効率化】 df %&gt;% rename_with(~str_replace(., &quot;bill&quot;, &quot;くちばし&quot;), starts_with(&quot;bill&quot;)) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; "],["filter.html", "4 ケース（行）を選ぶ 4.1 基本", " 4 ケース（行）を選ぶ パッケージdplyrの関数filter() tidyな世界では「行 = ケース, 個人（wide形式の場合）」 ケースが多い時に関心あるケースに限定したデータにしたい データフレームとして出力した結果を限定して見るときに使うことが多い気がする 4.1 基本 filter( )の引数に論理式（TRUE or FALSEになるもの）を入れる 論理式の部分について，最初の内はselect( )に入れるものと違って混乱するかもしれないが，慣れると段々分かってくると思う df %&gt;% filter(species == &quot;Adelie&quot;) ## # A tibble: 152 x 8 ## species island bill_length_mm bill_depth_mm flipper_length_~ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 149 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 種（species）がAdelieのケースのみ選ばれた df %&gt;% filter(bill_length_mm &gt;= 50) ## # A tibble: 57 x 8 ## species island bill_length_mm bill_depth_mm flipper_length_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Gentoo Biscoe 50 16.3 230 ## 2 Gentoo Biscoe 50 15.2 218 ## 3 Gentoo Biscoe 50.2 14.3 218 ## # ... with 54 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; くちばしの長さ（bill_length_mm）が50以上のケースのみ選ばれた "],["mutate.html", "5 新しい変数（列）の作成：mutate( ) 5.1 データ読み込み 5.2 基本 5.3 変数の型の変換 5.4 across( )の特徴 5.5 合計点の作成 5.6 変数の値を数値から文字列に変える 5.7 連番からIDの作成 5.8 逆転項目を作る 5.9 【別解】合計点の作成 5.10 連続変数をカテゴリに区分する", " 5 新しい変数（列）の作成：mutate( ) パッケージdplyrの関数mutate() 新しい変数の列を作成する mutateの機能解説 効率化のためのacross() 5.1 データ読み込み psychToolsパッケージに入っている国際パーソナリティ項目プールからの2800名分のデータ 質問項目が25問あり，5つの構成概念（ここでは因子という）に対応する項目への回答を足し合わせたスコアを計算する 性，教育歴，年齢の変数もあり 項目に対し想定される因子（因子名の頭文字が変数名と対応） Agree A1からA5 Conscientious C1からC5 Extraversion E1からE5 Neuroticism N1からN5 Openness O1からO5 回答選択肢 1 Very Inaccurate まったくあてはまらない 2 Moderately Inaccurate あてはまらない 3 Slightly Inaccurate ややあてはまらない 4 Slightly Accurate ややあてはまる 5 Moderately Accurate あてはまる 6 Very Accurate 非常にあてはまる # パッケージが入ってなければ下記実行 # install.packages(&quot;psychTools&quot;) df_bfi &lt;- psychTools::bfi %&gt;% as_tibble() # 表示に便利なtibble形式に 5.2 基本 データフレームに新しい列を計算して追加するまたは置き換える関数 mutate( )の中に新しく作成する変数名を入れ，=でつないで計算式を入れる ここでは，まず変数A1の平均値（全ケース同じ値が入る）を計算し，個々の値の差分をする例を示す df_bfi %&gt;% select(A1) %&gt;% # A1のみを残す mutate( mean_a1 = mean(A1, na.rm = TRUE), # A1の平均値を作成（NAは除外） dif_a1_mean = A1 - mean_a1) # 各個体のA1と平均値の差分を計算 ## # A tibble: 2,800 x 3 ## A1 mean_a1 dif_a1_mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 2.41 -0.413 ## 2 2 2.41 -0.413 ## 3 5 2.41 2.59 ## # ... with 2,797 more rows mean_a1列にはA1の平均値がすべて同じ値で入る（平均値だけの計算がしたければ6を参照） dif_a1_mean列は，A1列からmean_a1列を引いた値が入る 5.3 変数の型の変換 変数には型の情報が伴い，統計解析やデータ加工の際に適切な型を求められることがあるため理解が必要 小数も扱う数値 &lt;dbl&gt; 整数 &lt;int&gt; 文字 &lt;chr&gt; 因子 &lt;fct&gt; 変数の型の確認は色々方法があるが，tibble形式のデータフレームならselect()でOK tibble形式でなくても，最後にglimpse()で確認可能 df_bfi %&gt;% select(gender, education) ## # A tibble: 2,800 x 2 ## gender education ## &lt;int&gt; &lt;int&gt; ## 1 1 NA ## 2 2 NA ## 3 2 NA ## # ... with 2,797 more rows df_bfi %&gt;% select(gender, education) %&gt;% glimpse() ## Rows: 2,800 ## Columns: 2 ## $ gender &lt;int&gt; 1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, ~ ## $ education &lt;int&gt; NA, NA, NA, NA, NA, 3, NA, 2, 1, NA, 1, NA, N~ gender, education列が &lt;int&gt; になっているので整数型になっている 5.3.1 型の変換 ここでは，2つの数値型変数gender, educationを因子型に変換する例を示す それぞれfactor()で因子型に変換 df_bfi %&gt;% select(gender, education) %&gt;% mutate(gender = factor(gender), education = factor(education)) ## # A tibble: 2,800 x 2 ## gender education ## &lt;fct&gt; &lt;fct&gt; ## 1 1 &lt;NA&gt; ## 2 2 &lt;NA&gt; ## 3 2 &lt;NA&gt; ## # ... with 2,797 more rows gender, education列が &lt;fct&gt; になっているので整数型になっている 5.3.2 【効率化】複数の変数に対し一度の指定で実行 変換したい変数が大量にあるときは上記の方法では大変 across()を使うと，指定した変数に対して同じ内容の処理なら 1回 ですむようになる かつてのmutate_at(), mutate_if()など df_bfi %&gt;% mutate(across(c(gender, education), factor)) %&gt;% select(gender, education) # 結果表示のため冗長だが変わった変数だけselect ## # A tibble: 2,800 x 2 ## gender education ## &lt;fct&gt; &lt;fct&gt; ## 1 1 &lt;NA&gt; ## 2 2 &lt;NA&gt; ## 3 2 &lt;NA&gt; ## # ... with 2,797 more rows 5.4 across( )の特徴 変数の指定に2.3で解説したヘルパー関数が使える df_bfi %&gt;% mutate(across(starts_with(&quot;n&quot;), factor)) %&gt;% select(starts_with(&quot;n&quot;)) # 結果表示のため ## # A tibble: 2,800 x 5 ## N1 N2 N3 N4 N5 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 3 4 2 2 3 ## 2 3 3 3 5 5 ## 3 4 5 4 2 3 ## # ... with 2,797 more rows ??で解説した文字も使える vars &lt;- c(&quot;N1&quot;, &quot;N2&quot;, &quot;N3&quot;, &quot;N4&quot;, &quot;N5&quot;) df_bfi %&gt;% mutate(across(all_of(vars), factor)) %&gt;% select(starts_with(&quot;n&quot;)) # 結果表示のため ## # A tibble: 2,800 x 5 ## N1 N2 N3 N4 N5 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 3 4 2 2 3 ## 2 3 3 3 5 5 ## 3 4 5 4 2 3 ## # ... with 2,797 more rows 5.4.1 【重要知識！】新しい変数名にして追加 ここはこの後色々なところで出てくる方法のため理解しておきたい 適用する関数をリストにする（list()に入れる）ことで，変数名を変更して追加できる list()に入れるときはこれまでと異なる書き方が必要になる 関数名の前に~（チルダ）が必要 list内の関数()内に.xが必要（この場合はxがなくてピリオドのみでも動く）。ここにacross()の第一引数に指定した変数が入っていくという意味 df_bfi %&gt;% mutate(across(c(gender, education), list(f = ~factor(.x)))) %&gt;% select(matches(&quot;gender|education&quot;)) ## # A tibble: 2,800 x 4 ## gender education gender_f education_f ## &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 NA 1 &lt;NA&gt; ## 2 2 NA 2 &lt;NA&gt; ## 3 2 NA 2 &lt;NA&gt; ## # ... with 2,797 more rows 因子型に変換した変数の末尾に_fがつく 5.5 合計点の作成 変数の四則演算の式を入れれば合計得点として計算された列をデータフレーム追加できる 別解で合計した例を，変数の逆転項目を反映させた後に 5.9 で解説する 項目数が多い場合などはこちらの方が効率化できる場合も df_bfi_n &lt;- df_bfi %&gt;% select(N1:N5) %&gt;% mutate(neuroticism = N1 + N2 + N3 + N4 + N5) df_bfi_n ## # A tibble: 2,800 x 6 ## N1 N2 N3 N4 N5 neuroticism ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 3 4 2 2 3 14 ## 2 3 3 3 5 5 19 ## 3 4 5 4 2 3 18 ## # ... with 2,797 more rows 5.5.1 足し上げる変数に欠損があるとどうなるか 合計得点の計算の場合，対象となる変数の内1つでもNAがあれば合計点もNAとなる df_bfi_n %&gt;% filter(is.na(neuroticism)) # neuroticismがNAなケースに限定 ## # A tibble: 106 x 6 ## N1 N2 N3 N4 N5 neuroticism ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 4 5 3 2 NA NA ## 2 NA 2 1 2 2 NA ## 3 1 2 1 2 NA NA ## # ... with 103 more rows 5.6 変数の値を数値から文字列に変える 一度因子型に変換してからforcatsパッケージのfct_recode( )関数を使うと簡単 ちゃんと変換の対応がついているかどうかをdplyrパッケージのcount( )関数で確認 適切に変換されていなければ，1 = male, 2 = female以外の組み合わせも発生するため count( )の強みは，出力がデータフレームで出てくる点なので，結果が扱いやすい df_bfi %&gt;% mutate(gender = factor(gender), gender_c = fct_recode(gender, male = &quot;1&quot;, female = &quot;2&quot;)) %&gt;% count(gender, gender_c) ## # A tibble: 2 x 3 ## gender gender_c n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 1 male 919 ## 2 2 female 1881 5.7 連番からIDの作成 dplyr::row_number()で行番号からIDを作成 df_bfi_n %&gt;% mutate(id = row_number()) ## # A tibble: 2,800 x 7 ## N1 N2 N3 N4 N5 neuroticism id ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 3 4 2 2 3 14 1 ## 2 3 3 3 5 5 19 2 ## 3 4 5 4 2 3 18 3 ## # ... with 2,797 more rows 5.7.1 【別解】行の名前を直接変数化 実はmutateを使わなくてもできて，データの最初に持ってこれる便利関数がある tibble::rowid_to_column() var =で変数名を指定 df_bfi_n %&gt;% rowid_to_column(var = &quot;id&quot;) ## # A tibble: 2,800 x 7 ## id N1 N2 N3 N4 N5 neuroticism ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 3 4 2 2 3 14 ## 2 2 3 3 3 5 5 19 ## 3 3 4 5 4 2 3 18 ## # ... with 2,797 more rows # この先使わないのでデータフレーム削除 rm(df_bfi_n) 5.8 逆転項目を作る 5.8.1 逆転項目の確認 bfiデータの場合，どの項目を逆転する必要があるかを示す情報（-変数名で表現）がパッケージに含まれている psychTools::bfi.keys で確認可能 したがって，“-A1”, “-C4”, “-C5”, “-E1”, “-E2”, “-O2”, “-O5”が対象 5.8.2 逆転（recode） dplyr::recode()を使用 入れ替えたい値をold = newで並べていく この等式の順番が他(mutateなど)と逆になるため，recode()は将来引退する可能性あり df_bfi %&gt;% mutate(A1_r = recode(A1, `1` = 6L, `2` = 5L, `3` = 4L, # oldの数値は` `で囲む必要がある `4` = 3L, `5` = 2L, `6` = 1L)) %&gt;% # newの数値にLがつくのは，型を整数のままにするため select(A1, A1_r) ## # A tibble: 2,800 x 2 ## A1 A1_r ## &lt;int&gt; &lt;int&gt; ## 1 2 5 ## 2 2 5 ## 3 5 2 ## # ... with 2,797 more rows 5.8.2.1 変数2つ以上を逆転 A1と同様に同じ形をくり返し変数名だけ変えていけばできるが，コードが長くなりミスも生じやすくなる df_bfi %&gt;% mutate(A1_r = recode(A1, `1` = 6L, `2` = 5L, `3` = 4L, `4` = 3L, `5` = 2L, `6` = 1L), C4_r = recode(C4, `1` = 6L, `2` = 5L, `3` = 4L, `4` = 3L, `5` = 2L, `6` = 1L)) %&gt;% select(A1, A1_r, C4, C4_r) ## # A tibble: 2,800 x 4 ## A1 A1_r C4 C4_r ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2 5 4 3 ## 2 2 5 3 4 ## 3 5 2 2 5 ## # ... with 2,797 more rows 5.8.2.2 【効率化】 変数2つ以上を逆転 5.4.1 で解説したlistに関数を入れる方法 df_bfi %&gt;% mutate(across(c(A1, C4, C5, E1, E2, O2, O5), list(r = ~recode(.x, `1` = 6, `2` = 5, `3` = 4, `4` = 3, `5` = 2, `6` = 1)))) %&gt;% select(A1, A1_r, C4, C4, C5, C5_r, E1, E1_r, E2, E2_r, O2, O2_r, O5, O5_r) ## # A tibble: 2,800 x 13 ## A1 A1_r C4 C5 C5_r E1 E1_r E2 E2_r O2 ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2 5 4 4 3 3 4 3 4 6 ## 2 2 5 3 4 3 1 6 1 6 2 ## 3 5 2 2 5 2 2 5 4 3 2 ## # ... with 2,797 more rows, and 3 more variables: O2_r &lt;dbl&gt;, ## # O5 &lt;int&gt;, O5_r &lt;dbl&gt; 5.8.3 【別解】逆転（公式） 項目を反転する公式が「(max + min) - 回答値」であることを利用 psych::reverse.code()のhelp参照 例：最小値1,最大値4の場合，max + min = 5となり，回答値が2の場合，5 - 2 = 3となり反転された結果となる min &lt;- 1 max &lt;- 6 df_bfi %&gt;% mutate(A1_r = max + min - A1, C4_r = max + min - C4) %&gt;% select(A1, A1_r, C4, C4_r) ## # A tibble: 2,800 x 4 ## A1 A1_r C4 C4_r ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 5 4 3 ## 2 2 5 3 4 ## 3 5 2 2 5 ## # ... with 2,797 more rows 5.8.3.1 【効率化】 変数2つ以上を逆転 ~の後に計算式がきても動く ここでは，max + min - .x の.xにacross内に置かれた変数が入っていく df_bfi %&gt;% mutate(across(c(A1,C4), list(r = ~ max + min - .x))) %&gt;% select(A1, A1_r, C4, C4_r) ## # A tibble: 2,800 x 4 ## A1 A1_r C4 C4_r ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 5 4 3 ## 2 2 5 3 4 ## 3 5 2 2 5 ## # ... with 2,797 more rows 5.8.3.2 逆転した変数を含むデータフレーム作成 これ以降で使用するため，項目を逆転した変数を格納しておく df_bfi &lt;- df_bfi %&gt;% mutate(across(c(A1, C4, C5, E1, E2, O2, O5), list(r = ~ max + min - .x))) 5.9 【別解】合計点の作成 base::rowSums( ) # 合計する項目の定義 Ag &lt;- df_bfi %&gt;% select(A1_r, A2:A5) %&gt;% names() Co &lt;- df_bfi %&gt;% select(C1:C3, C4_r, C5_r) %&gt;% names() Ex &lt;- df_bfi %&gt;% select(E1_r, E2_r, E3:E5) %&gt;% names() Ne &lt;- df_bfi %&gt;% select(N1:N5) %&gt;% names() Op &lt;- df_bfi %&gt;% select(O1, O2_r, O3, O4, O5_r) %&gt;% names() df_bfi &lt;- df_bfi %&gt;% mutate( Agree = rowSums(across(all_of(Ag))), Conscientious = rowSums(across(all_of(Co))), Extraversion = rowSums(across(all_of(Ex))), Neuroticism = rowSums(across(all_of(Ne))), Openness = rowSums(across(all_of(Op))) ) 5.9.1 【確認】 df_bfi %&gt;% select(all_of(Ag), Agree) ## # A tibble: 2,800 x 6 ## A1_r A2 A3 A4 A5 Agree ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 5 4 3 4 4 20 ## 2 5 4 5 2 5 21 ## 3 2 4 5 4 4 19 ## # ... with 2,797 more rows df_bfi %&gt;% select(all_of(Ex), Extraversion) %&gt;% filter(is.na(Extraversion)) ## # A tibble: 87 x 6 ## E1_r E2_r E3 E4 E5 Extraversion ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 4 NA 4 3 NA ## 2 6 6 4 4 NA NA ## 3 2 NA 3 2 3 NA ## # ... with 84 more rows 5.10 連続変数をカテゴリに区分する 5.10.1 分布の把握 変数ageのヒストグラムを描き，中央値を確認する 単純に確認したいだけなら，従来のRでの書き方が楽 # ヒストグラム描画 hist(df_bfi$age) # 中央値 median(df_bfi$age) ## [1] 26 5.10.2 2区分 dplyrパッケージのif_else( )関数で条件式（TRUEまたはFALSEを返すもの）によって値を2区分する 構造：if_else(条件式, TRUEの場合の値, FALSEの場合の値) TRUEの場合の値, FALSEの場合の値はそれぞれ文字型を入れることもできる（例:“27歳以上”, “27歳未満”） res_age2 &lt;- df_bfi %&gt;% mutate(age2 = if_else(age &gt;= 27, 1, 0)) %&gt;% select(age, age2) res_age2 %&gt;% count(age2) ## # A tibble: 2 x 2 ## age2 n ## &lt;dbl&gt; &lt;int&gt; ## 1 0 1495 ## 2 1 1305 5.10.2.1 確認 age &gt;= 27が1，27未満が0にコーディングされているかfilterで限定して確認 res_age2 %&gt;% filter(age &gt;= 20 &amp; age &lt;= 30) %&gt;% count(age, age2) %&gt;% print(n = 11) ## # A tibble: 11 x 3 ## age age2 n ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 20 0 212 ## 2 21 0 144 ## 3 22 0 122 ## 4 23 0 138 ## 5 24 0 105 ## 6 25 0 113 ## 7 26 0 99 ## 8 27 1 97 ## 9 28 1 86 ## 10 29 1 78 ## 11 30 1 65 念のため最初3行（1-3行目）と最後3行（n-2行目からn行目）も確認 dplyr( )::slice( )で1:3行目と最後の3行を表示させる res_age2 %&gt;% count(age, age2) %&gt;% slice(1:3, (n()-2):n()) ## # A tibble: 6 x 3 ## age age2 n ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 3 0 1 ## 2 9 0 1 ## 3 11 0 3 ## 4 72 1 1 ## 5 74 1 1 ## 6 86 1 1 rm(res_age2) 5.10.3 3区分以上 年齢層を10歳区切りでカテゴリ化 res_age6 &lt;- df_bfi %&gt;% mutate(age6 = case_when( age &lt; 20 ~ &quot;20歳未満&quot;, age &gt;= 20 &amp; age &lt; 30 ~ &quot;20-29歳&quot;, age &gt;= 30 &amp; age &lt; 40 ~ &quot;30-39歳&quot;, age &gt;= 40 &amp; age &lt; 50 ~ &quot;40-49歳&quot;, age &gt;= 50 &amp; age &lt; 60 ~ &quot;50-59歳&quot;, age &gt;= 60 ~ &quot;60歳以上&quot; )) # 確認するには以下のコードの最初の2行だけでよいが，出力が長いためランダムに10件抽出しageの昇順にしてある res_age6 %&gt;% count(age, age6) %&gt;% slice_sample(n = 10) %&gt;% arrange(age) ## # A tibble: 10 x 3 ## age age6 n ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 12 20歳未満 28 ## 2 19 20歳未満 190 ## 3 28 20-29歳 86 ## 4 40 40-49歳 56 ## 5 49 40-49歳 16 ## 6 51 50-59歳 24 ## 7 61 60歳以上 4 ## 8 65 60歳以上 1 ## 9 67 60歳以上 3 ## 10 70 60歳以上 1 rm(res_age6) "],["summarise.html", "6 要約値を作る：summarise( ) 6.1 基本 6.2 複数の計算 6.3 層別（グループ別）集計 6.4 【効率化】関数にする", " 6 要約値を作る：summarise( ) パッケージdplyrの関数summarise() 結果をデータフレームとして出力するため，扱いが便利 データの要約作業はデータを知るうえで頻繁に行うことが想定される 便利な要約パッケージが色々あるものの，summarise()を使いこなせると役に立つことが多い 6.1 基本 ( )の中に出力したい変数名を書き，=の後に関数を入れる NAがある場合，引数na.rm = TRUEがないと結果が出ないので，ほとんどの場合つけて置いた方がよい df %&gt;% summarise(blm_平均値 = mean(bill_length_mm, na.rm = TRUE)) ## # A tibble: 1 x 1 ## blm_平均値 ## &lt;dbl&gt; ## 1 43.9 6.2 複数の計算 複数の変数について平均値とSDとnを出したいときは，基本知識では全部書くので長くなる df %&gt;% summarise(blm_mean = mean(bill_length_mm, na.rm = TRUE), bdm_mean = mean(bill_depth_mm, na.rm = TRUE), blm_sd = sd(bill_length_mm, na.rm = TRUE), bdm_sd = sd(bill_depth_mm, na.rm = TRUE), blm_n = sum(!is.na(bill_length_mm)), bdm_n = sum(!is.na(bill_depth_mm))) ## # A tibble: 1 x 6 ## blm_mean bdm_mean blm_sd bdm_sd blm_n bdm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 43.9 17.2 5.46 1.97 342 342 6.2.1 【効率化】 5.3.2で出てきたacross()がここでも有用 across()の第一引数に指定したい変数名ベクトル，またはヘルパー関数を入れる 実行したい関数をlist内に名前（接尾辞）をつけて列挙し，関数の前に~をつける df %&gt;% summarise(across(c(bill_length_mm, bill_depth_mm), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) ## # A tibble: 1 x 6 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 ## # ... with 3 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt;, bill_depth_mm_n &lt;int&gt; across()ではヘルパー関数が使える！ df %&gt;% summarise(across(starts_with(&quot;bill&quot;), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) ## # A tibble: 1 x 6 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 ## # ... with 3 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt;, bill_depth_mm_n &lt;int&gt; 6.2.2 【並び替え】 tidyr::pivot_longer()で，データフレームの行列入れ替えができる 引数をnames_patternとnames_toを下記のように指定することで，変数の接尾辞を列名にできる df %&gt;% summarise(across(bill_length_mm:body_mass_g, list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) %&gt;% pivot_longer(everything(), names_to = c(&quot;items&quot;, &quot;.value&quot;), # &quot;.value&quot;の部分を列名に names_pattern = &quot;(.*)_(.*)&quot;) # 正規表現 ## # A tibble: 4 x 4 ## items mean sd n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 bill_length_mm 43.9 5.46 342 ## 2 bill_depth_mm 17.2 1.97 342 ## 3 flipper_length_mm 201. 14.1 342 ## 4 body_mass_g 4202. 802. 342 6.3 層別（グループ別）集計 group_by( )にグループを表す変数を指定するとできる df %&gt;% group_by(species) %&gt;% summarise(across(c(bill_length_mm, bill_depth_mm), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE)))) ## # A tibble: 3 x 5 ## species bill_length_mm_mean bill_length_mm_~ bill_depth_mm_m~ ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie 38.8 2.66 18.3 ## 2 Chinstrap 48.8 3.34 18.4 ## 3 Gentoo 47.5 3.08 15.0 ## # ... with 1 more variable: bill_depth_mm_sd &lt;dbl&gt; グループを重ねることも可能 df %&gt;% group_by(species, sex) %&gt;% summarise(across(c(bill_length_mm, bill_depth_mm), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE)))) ## # A tibble: 8 x 6 ## # Groups: species [3] ## species sex bill_length_mm_mean bill_length_mm_sd ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie female 37.3 2.03 ## 2 Adelie male 40.4 2.28 ## 3 Adelie &lt;NA&gt; 37.8 2.80 ## 4 Chinstrap female 46.6 3.11 ## 5 Chinstrap male 51.1 1.56 ## 6 Gentoo female 45.6 2.05 ## 7 Gentoo male 49.5 2.72 ## 8 Gentoo &lt;NA&gt; 45.6 1.37 ## # ... with 2 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt; 6.4 【効率化】関数にする 6.4.1 基本 関数名 &lt;- function(引数){ 計算式やコード } で関数を定義できる add_one &lt;- function(x){ x + 1 } add_one(2) ## [1] 3 6.4.2 複数変数の平均値とSDとnを計算する関数 引数にデータフレーム（data）と変数（vars）を入れる mean_sd_n &lt;- function(data, vars){ data %&gt;% summarise(across({{vars}}, list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) } ここで定義した関数mean_sd_n( )にデータフレームと変数を入れると結果が表示される mean_sd_n(df, bill_length_mm) ## # A tibble: 1 x 3 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 vasの部分はacross( )の第一引数に入れるものと同じ指定ができるため，変数ベクトルやヘルパー関数が入る # 変数ベクトル mean_sd_n(df, c(flipper_length_mm, body_mass_g)) ## # A tibble: 1 x 6 ## flipper_length_mm_mean flipper_length_mm_sd flipper_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 201. 14.1 342 ## # ... with 3 more variables: body_mass_g_mean &lt;dbl&gt;, ## # body_mass_g_sd &lt;dbl&gt;, body_mass_g_n &lt;int&gt; # 文字でも可能 # mean_sd_n(df, c(&quot;flipper_length_mm&quot;, &quot;body_mass_g&quot;)) # ヘルパー関数 mean_sd_n(df, starts_with(&quot;bill&quot;)) ## # A tibble: 1 x 6 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 ## # ... with 3 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt;, bill_depth_mm_n &lt;int&gt; "],["あとがき.html", "あとがき", " あとがき あとがき 本書の執筆にあたり、同人誌制作の先輩である天川榎@EnokiAmakawa氏から背中押し＆多くの助言をいただきました。この場を借りてお礼申し上げます。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
