[["index.html", "がんばらないデータ加工 Rによる繰り返し作業入門 前編 はじめに 概要 本書の特徴 想定読者 各章の紹介 執筆環境 注意事項など 関連情報", " がんばらないデータ加工 Rによる繰り返し作業入門 前編 やわらかクジラ はじめに 概要 本書の目的 データ加工での面倒な作業をRでらくらく実行できるようになるための基礎知識を紹介 本書の内容 Rのモダンな方法を使ったデータ加工の過程（例：前処理、データクリーニング、データクレンジング、データラングリングなど）で用いる基本関数の紹介 実際は核心の部分に入る前の準備段階までにとどまる。タイトルに「前編」とあるのはその理由による 本当は，複数データセットの複数変数をいっぺんに加工，集計，視覚化！みたいなのをまとめたかったが，そこに入るための事前知識が思っていたより多かったため，まずはそれらを解説することに徹した 執筆動機 本書を書こうと思ったのは拙既刊書『Rで読むExcelファイル』と同じく，「RとRStudioを使いたい！と思う人がもっと増えればいいのに」という願いから 今後の展望 よりタイトルの内容に沿った次回作の「後編」（もしかしたら「中編」も）をお楽しみに！ 本書の内容は、githubレポジトリですべて公開 本書の特徴 タイトルの「がんばらない」とは，単純作業のくり返しに無駄なエネルギーを注がなくてよいようにすること 扱う内容は自分が学び始めの時に教えてもらいたかったことが中心 これまでの解説で不足していると考えられるポイント 便利な関数や基本的な使い方の解説は多いが，データ加工の実務上知りたいコード例が豊富なわけではない 同じ作業を大量の変数についてくり返し実行したい時のやり方の解説は少ない 本書の強み くり返し同じ作業する部分を効率化したコードを併せて解説する点 自分の学習経験から，そのコード例が知りたかったんだ！という実用的な方法を整理 まずモダンなRのデータ加工法での基本の書き方を解説した後に，【効率化】でより効率的にコードを書く解説を行う 【効率化】のタグが本書の核心になる。手作業の繰り返しをなるべく避けることが目指すべき点 冗長だが【別解】を示すことで様々な関数の働きを理解でき，手持ちの武器が増えデータ加工の幅が広がる 想定読者 RとRStudioをダウンロードしてPCにインストールまでできることが最低条件 web上に様々な解説があり，あとは基本的にOKしていけばできるはず 例えば公的な資料では総務省ホームページ「総務省 ICTスキル総合習得プログラム コース4 （オープンデータ・ビッグデータ利活用事例） 4-3 プログラミングによるビッグデータの分析（R）」(https://www.soumu.go.jp/ict_skill/)など Windows10だとインストール時にうまくいかないことがあり，自分もくじけそうになったことがあったが，それは乗り越えてしまうと戻りたくないので今回は解説あきらめた どうしてもインストールできなかったら，ブラウザから実行可能なRStudio Cloudを使って練習できる 初学者から始めてちょっと背伸びできるくらいまでが到達目標 各章の紹介 まず1章では、RとRStudioに初めて触れる方，初学者を対象とした前提知識を解説する。ゆくゆく楽をするためには避けて通れない知識なので，用語になじんでおきたい 2章はデータの列（変数）を選ぶ方法を解説する。データをコンパクトにしたり，後のデータ解析等で必要な変数を取得したりするなど，データ加工プロセス全体で必要な基本知識もあるので最初に学んでおきたい 3章はデータの列名（変数名）を変える方法について解説する。単純に見えるがデータ加工の際になくてはならない技術である。効率化させるためには初心者から少し脱する必要があり，奥が深い 4章はデータの行（ケースまたはオブザベーション）を選ぶ方法を解説する。データや加工した結果，分析した結果をコンパクトにするのに役立つ。 5章はデータに新しい列を追加する方法について解説する。例えば合計点の作成や，年齢層カテゴリや2区分変数（いわゆるダミー変数）の作成など，変数を計算して新しい変数を作る作業はよく発生する。効率化のために避けて通れないacross( )についてもここで解説する 6章は要約値の計算について解説する。実務では大量の変数を一気に処理する必要がある場面が多いので，効率化を意識した説明を多く入れている 執筆環境 本書はbookdownにて執筆 表紙のタイトルは「あずきフォントB」v1.20を使用 RおよびRStudio、パッケージのバージョン rstudioだけなぜか表示されないので手動で… バージョン 2021.09.1+372 Ghost Orchid (desktop) ind values version R version 4.1.0 (2021-05-18) os Windows 10 x64 (build 19043) system x86_64, mingw32 date 2022-01-22 package loadedversion bookdown 0.24 tidyverse 1.3.1 注意事項など 本書の内容はすべてwindows環境を想定 この本に書いてある内容は、筆者が学習したことをまとめているものにすぎないため、正常な動作の保証はできない。使用する際は、自己責任で 関連情報 『Rで読むExcelファイル』 技術書典9で頒布したRでのExcelおよびcsvファイル読み込み解説本 github ggplot2の辞書 視覚化のためのggplot2パッケージの辞書的メモ "],["premise.html", "1 前提知識 1.1 RStudioの使い方 1.2 本書に出てくるコード部分の見方 1.3 プロジェクト 1.4 パッケージ 1.5 関数 1.6 オブジェクト 1.7 データフレーム 1.8 %&gt;% （パイプ演算子） 1.9 困ったときは", " 1 前提知識 ここに出てくる用語は初学者にとってなじみがないものばかりかもしれないが，Rでデータ加工をらくらくできるようになるためには避けて通れない これ以降はここで解説した用語を説明なしに解説に使うので，分からない言葉に出くわしたらここに戻ってこよう 1.1 RStudioの使い方 1.1.1 起動画面 RStudioを最初に起動すると大体以下のような画面になる Figure 1.1: RStudioの起動画面 1.1.2 見た目の変更 好みまたは目に優しい画面にするため，RStudioの色合いを下記から変更できる メニューのTools &gt; Global Options &gt; Appearance &gt; Editor themeから選び，OKを押す 筆者はTommorow Night Brightを使用 以下の説明は変更後の画面で示す Figure 1.2: テーマの設定画面 1.1.3 コードの実行の仕方 コンソールに直接コードを入力し出力を確認できる ちょっとした確認には便利だが，たくさん書きたい時や，内容を保存したい時は不向き Figure 1.3: コンソールに直接 R Scriptに書くと，たくさん書けるし保存も簡単でおすすめ。色分けもされる 慣れたらR Markdownを使うとhtmlレポートにまとめやすくなりもっと便利になる 下図の〇で囲んである左上の緑＋がついているアイコンから，またはFile &gt; New file &gt; R ScriptでR Scriptを開く Figure 1.4: Rスクリプトを開く R Scriptを開くとデフォルトでは左上にペインが開き，ここにコードを記述できる Figure 1.5: Rスクリプトに書く 1.1.4 Windowsユーザーにつきものの文字化け対策 Windowsだけの問題かもしれず，今後はもしかしたら不要になっていくかもしれないが，Windows10以前の場合，RStudio上で文字コードをUTF-8に指定しておく方が文字化けに悩まなくてすみそう Tools &gt; Global Options &gt; Code &gt; Saving &gt; Default text encodingからUTF-8選び，OKを押す 同様にTools &gt; Project Options &gt; Code Editing &gt; Text encodingのところもUTF-8にしておく Figure 1.6: 文字エンコーディングの指定 上記設定をした後で，他の環境で作られたR ScriptファイルやR Markdownファイルを開くときに文字化けする場合は，File &gt; Reopen with EncodingからCP932（つまりShift-Jis）を選ぶとうまくいくかもしれない 1.2 本書に出てくるコード部分の見方 グレーの背景部分はRのコードが書いてあり，その下の##で始まる部分は出力結果を表す 1 + 1 ## [1] 2 ここでは1 + 1がコード部分で，## [1] 2が出力結果部分 [1]というのは，その次にくる値（ここでは１つしかないが）が何番目にあるかを示している たとえば，1から50までの数値を出力してみる コロン:で最初と最後の値をつなぐことで連番を表現できる 1:50 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ## [26] 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 コード部分に#で始まる文章がある場合は，コメントを表す。ここは実行されないので説明のために書かれる # *（アスタリスク） は掛け算であることを示す 2 * 3 # ここにもコメントを入れられる ## [1] 6 1.3 プロジェクト データを加工して解析する際に、1つのフォルダ（サブフォルダも含む）の中に関連するデータやコードなどをまとめておき、そのフォルダをプロジェクトと設定する これにより、ファイルの読み書きの際の場所指定をいちいち意識しないで作業できるようになる RStudio画面の右上にProject設定のメニューがある Project (None) &gt; New Project &gt; Existing Directoryと選び，プロジェクトにしたいフォルダを設定する Figure 1.7: プロジェクトの設定 1.4 パッケージ 様々な関数やデータなどがまとまっていて，読み込むと色々なことができる 逆にいえば読み込まないと便利な作業ができないことが多い インストールされているパッケージはRStudioのデフォルト画面で右下にあるウィンドウ（ペインと呼ぶ）のパッケージタブで確認可能（Figure1.8） 入っていないパッケージは，インターネットにつながっていれば以下の方法でインストールできる パッケージタブのinstallをクリックして出てくるウィンドウでパッケージ名を入力 コマンドからinstall.packages(\"パッケージ名をここに入れる\") Figure 1.8: パッケージタブからのインストール 例：library(tidyverse)またはrequire(tidyverse) のように書くことで読み込める パッケージを読み込まなくても，パッケージ名::関数名( )でパッケージ内の関数が使える どのパッケージの関数か明示するのにも便利なので，本書では多用する 以下，例えば「パッケージdplyrの関数select( )」はdplyr::select( )と表現する モダンなRのデータ加工に必須なパッケージをまとめて読み込んでくれるtidyverseをまず読み込んでおく 以降のコードはすべてtidyverseを読み込んだ前提で進める library(tidyverse) 1.5 関数 データ加工においてほとんどの人は絶対お世話になるもの 適切な値や変数などを指定すれば，データの処理や計算，統計解析など様々な処理を簡単に実行してくれる データ加工の技術は，色々な便利関数をどの場面でどうやって使うかにつきる 例えばmean( )などのように関数名( )で出てくるので，( )で囲まれてる所を見たらほぼ関数だと思えばよさそう 本書の2章～6章はすべて基本関数の解説 ( )の中に入る値を引数（ひきすう）と呼ぶ 引数は,でつないで追加していき，これによって実行したい処理のカスタマイズが可能 関数の( )の最初の位置に来るものを第一引数という 1.5.1 例 1.5.1.1 複数のものを1つにする: c( ) ベクトルを作る（複数のものを1つにする）ための関数 ベクトルと聞くと数学苦手だった人はいやな記憶を思い出すかもしれないが，Rではとにかく「複数のものを１つにしたもの」と理解しておけば何となると思う c( )は慣れてる人は当たり前に使っているので，初学者にとって理解しとくとよい最重要関数と思われる ベクトルは，後に解説するデータフレームでの列単位のデータを扱う際にも有用 c(1,2,3) ## [1] 1 2 3 c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) # &quot; &quot;で囲まれる値は文字を表す ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; # 複数あるように見えるが実は1つのベクトルになっている例 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 1.5.1.2 平均値：mean( ) 引数にベクトルを入れることで平均値を計算する 1つのベクトルはデータフレームの1つの列（変数）の単位と同じなので，ここでは横に並んでいるがデータフレーム的にイメージしたら縦に並んでるとみなすと分かりやすいかも mean(c(1,2,3)) ## [1] 2 # 欠損値（NA）があると結果がNA mean(c(1, NA, 3)) ## [1] NA # 引数にna.rm = TRUEを追加すると結果が出る # 基本的に実務上は常につけておいたほうがよい mean(c(1, NA, 3), na.rm = TRUE) ## [1] 2 1.6 オブジェクト 計算の結果や，複数の数値や文字など（他にも色々）を1つの文字列に格納することができ，その後のコードで活用できる &lt;-の矢印の先にあるのがオブジェクト。RStudioではショートカットalt + -で出せる(MacはOption + -) この後説明するデータフレームもオブジェクトに入れられる データの少ないミニデータを作る時や，計算結果を格納するときに多用 1.6.1 例 res &lt;- 1 + 1 res ## [1] 2 res2 &lt;- c(1, 2:4, 5) res2 ## [1] 1 2 3 4 5 res3 &lt;- c(&quot;a&quot;, &quot;b&quot;) res3 ## [1] &quot;a&quot; &quot;b&quot; rm(res, res2, res3) 1.7 データフレーム 行（ケースまたはオブザベーション）と列（変数）が碁盤の目のようになった集まりの形のデータ（Figure1.9） Excelで表現するのであれば通常1行目に列名が入り、2行目以降が個別のケース（データ）を表す形。Rのデータフレームでは列名は別途与えられ，1行目からケースが表される（Figure1.10） データ解析において便利で分かりやすいため、本書ではデータフレームの形で説明していく Rのモダンな方法では，データの加工や統計処理のプロセスをデータフレームの形で返すことが多い 上記のような状態をtidy(読み：タイディー，意味：整然)と呼び，データ加工において理想的な形とされている Figure 1.9: Rのデータフレーム(tibble形式) Figure 1.10: Excel画面風なイメージ オブジェクトに格納することで，別のデータフレームを作れる 列単位で取り出すとベクトルになる 本書では，データフレームの中でも表示に便利なtibble形式を使う デフォルトでは最初の10行が表示されるが，本書では紙面の都合上，表示行数をしぼっている 1.7.1 本書で使う主なデータ例 1.7.1.1 ペンギンデータ palmerpenguinsパッケージのpenguinsデータ（CC0） 最初からtibble形式になっている # パッケージが入ってなければ下記実行 # install.packages(&quot;palmerpenguins&quot;) palmerpenguins::penguins ## # A tibble: 344 x 8 ## species island bill_length_mm bill_depth_mm flipper_length_~ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; tibble形式のデータフレームの出力の見方 出力の最上段にあるA tibble: 344 x 8で，tibble形式のデータフレーム，344行 × 8列という情報が分かる flipper_length_~ のように，長い変数名は~で省略して表示される 変数名の下の行にある&lt;fct&gt;, &lt;dbl&gt;, &lt;int&gt;は変数の型を示し，それぞれ因子型，数値型，整数型であることを示している。詳しくは5.3で説明する 下から2行目にある... with 341 more rows, and 3 more variables:で，さらに341行と3列が非表示であることが分かる 非表示になった変数名は最下部に表示される 本書では最初の3行の表示のみに絞っているが，任意の行数を表示させたい場合は，print( )関数を使う palmerpenguins::penguins %&gt;% print(n = 15) ## # A tibble: 344 x 8 ## species island bill_length_mm bill_depth_mm flipper_length_~ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgers~ 39.1 18.7 181 ## 2 Adelie Torgers~ 39.5 17.4 186 ## 3 Adelie Torgers~ 40.3 18 195 ## 4 Adelie Torgers~ NA NA NA ## 5 Adelie Torgers~ 36.7 19.3 193 ## 6 Adelie Torgers~ 39.3 20.6 190 ## 7 Adelie Torgers~ 38.9 17.8 181 ## 8 Adelie Torgers~ 39.2 19.6 195 ## 9 Adelie Torgers~ 34.1 18.1 193 ## 10 Adelie Torgers~ 42 20.2 190 ## 11 Adelie Torgers~ 37.8 17.1 186 ## 12 Adelie Torgers~ 37.8 17.3 180 ## 13 Adelie Torgers~ 41.1 17.6 182 ## 14 Adelie Torgers~ 38.6 21.2 191 ## 15 Adelie Torgers~ 34.6 21.1 198 ## # ... with 329 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 1.8 %&gt;% （パイプ演算子） 名前はパイプで発音は”and then” （参照） コードを読みやすくするための便利な機能を持つ演算子。初めてみた人は全然わからないと思うが，この本を読んでコードを書きはじめてみたらこれなしではいられなくなるくらいお世話になると思う 主に使用が想定される場面でざっくりいうと，「このデータフレームに対して%&gt;%の後にある関数を適用する」という機能 具体的な使用法は2.2.1で解説 RStudioのショートカットはCtrl + Shift + M(MacはCmd + Shift + M)。たぶん，RStudio以外でもこのショートカット押してしまうぐらい中毒性がある R version 4.1からは|&gt;が大体同じ機能を持つ演算子して実装されたので，特にパッケージの読み込みをせずに使えるようになった。こちらを使う説明も今後増えていくと思われる ショートカットで出るパイプを|&gt;に切り替えたい場合は，RStudioのTools &gt; Global Options &gt; Code &gt; Editing &gt; use native pipe operatorにチェックを入れる 現時点ではデータフレームを第一引数へ渡す形式でない関数の場合（回帰分析のlm( )など），工夫が必要な場合があるようなので，本書では%&gt;%を使用 1.9 困ったときは 関数の使い方，引数の入れ方は大抵忘れるので，ヘルプのexampleを見て思い出す場合が多い コンソールに?関数名の用に入れて実行する（例：?rename） 右下ペインのHelpタブで検索する Figure 1.11: ヘルプの確認 チートシートを見る メニューのHelp &gt; Cheat Sheets &gt; Browse Cheat Sheetsから掲載サイトに行ける エラーメッセージを\" \"で囲んでググる r-wakalangの#r_beginnersチャンネルで質問する "],["select.html", "2 列（変数）を選ぶ：select 2.1 使用データ 2.2 基本 2.3 変数の指定に便利なヘルパー関数 2.4 特定の変数を選ばない（落とす） 2.5 関心のある変数名を取得する", " 2 列（変数）を選ぶ：select 本章のポイント 列（変数）を選ぶ関数dplyr:select( ) tidyな世界では「列名 = 変数名」 変数が多い時に関心ある変数に限定したデータにしたい 関心ある変数の名前を取得したい 後々出てくる繰り返し作業で便利なヘルパー関数について知る 2.1 使用データ データの指定を簡単にするために，penguinsデータをdfと読み込む palmerpenguins::penguinsというのは，「palmerpenguinsパッケージの::penguinsデータ」という意味 df &lt;- palmerpenguins::penguins # データの表示 df ## # A tibble: 344 x 8 ## species island bill_length_mm bill_depth_mm flipper_length_~ ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 読み込みの様々な方法については拙書『Rで読むExcelファイル』参照 2.2 基本 select( )の中に関心のある変数名を,をつけて並べる 変数は1つからOK %&gt;%についてはすでに1.8で説明したが，この後また補足を説明するのでまずは何も考えずに使ってみよう 以降すべてtidyverseパッケージを読み込んだ前提で進める（1.4参照） # まだtidyverseパッケージを読み込んでない場合は以下の#を外して実行 # library(tidyverse) df %&gt;% select(bill_length_mm, bill_depth_mm) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows 新しいデータフレームを作りたい場合は&lt;-を使って新しいオブジェクトに格納する df2 &lt;- df %&gt;% select(bill_length_mm) df2 ## # A tibble: 344 x 1 ## bill_length_mm ## &lt;dbl&gt; ## 1 39.1 ## 2 39.5 ## 3 40.3 ## # ... with 341 more rows # 一時的に見せただけなので削除 rm(df2) 2.2.1 【補足】%&gt;% の意味 1.8で説明したパイプ演算子の実例を解説する 基本的にselect( )を始めとしたモダンなRの処理は，以下のように第一引数にデータフレームを指定する select(df, bill_length_mm) ## # A tibble: 344 x 1 ## bill_length_mm ## &lt;dbl&gt; ## 1 39.1 ## 2 39.5 ## 3 40.3 ## # ... with 341 more rows %&gt;%の役割は，その左側にあるものを右側の関数の第一引数に入れる，ということなので，第一引数にデータフレームが来ることが決まっていれば，常に次のようにかける このようにすると複雑な処理を重ねていく場合も，コードの可読性が高まるので，コードを共有してチーム作業するデータ加工の過程で有用 df %&gt;% select(bill_length_mm) ## # A tibble: 344 x 1 ## bill_length_mm ## &lt;dbl&gt; ## 1 39.1 ## 2 39.5 ## 3 40.3 ## # ... with 341 more rows 2.2.2 範囲指定 関心ある変数が指定された範囲に含まれていれば:（コロン）でつなげて取得できる 変数の連番をまとめて指定する時などに便利（例 変数1:変数100） df %&gt;% select(bill_length_mm:flipper_length_mm) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 範囲に加えて追加の変数を追加できる 飛び飛びの変数群を選びたいときに有用 df %&gt;% select(bill_length_mm:flipper_length_mm, sex) ## # A tibble: 344 x 4 ## bill_length_mm bill_depth_mm flipper_length_mm sex ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;fct&gt; ## 1 39.1 18.7 181 male ## 2 39.5 17.4 186 female ## 3 40.3 18 195 female ## # ... with 341 more rows 2.2.3 中身が文字でも動く 変数名が\" \"で囲われていると，Rでは文字(character)だと認識される select( )は文字の変数名を与えても動く df %&gt;% select(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows これは効率化を図りたいときに重要な特徴 select( )の中にたくさんの変数名を並べるより，事前に指定しておきベクトルとして代入した方が読みやすい あらかじめ作成したベクトルとして代入するときは，all_of( )で囲む必要がある 様々なコード例でこの事前指定が多用されるので慣れるとよい # あらかじめオブジェクト（ここではvars）に引数を格納して後で使えるようにする vars &lt;- c(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;) df %&gt;% select(all_of(vars)) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows ここでvarsは文字ベクトル（vector）のオブジェクトとなっている all_of( )の中に文字ベクトルを指定することで，それぞれの中身を変数名として認識する 以前使われていたone_ofは現在は非推奨 2.2.4 [練習問題] dfデータで変数speciesからbill_length_mmまでの並び，およびyearの計4列にしてデータフレームを表示させよう dfデータで変数bill_length_mmからbody_mass_gまでの並びの計4列を文字ベクトルにしたうえでselectで選んでデータフレームを表示させよう 2.3 変数の指定に便利なヘルパー関数 selection helperと呼ばれるtidyselectパッケージの関数群 select( )の所で解説されることが多いが，後から出てくるacross()と併せた活用場面が多いため，なじんでおくと後から楽になる 2.3.1 変数名の最初の文字列 billから始まる変数を選ぶ df %&gt;% select(starts_with(&quot;bill&quot;)) ## # A tibble: 344 x 2 ## bill_length_mm bill_depth_mm ## &lt;dbl&gt; &lt;dbl&gt; ## 1 39.1 18.7 ## 2 39.5 17.4 ## 3 40.3 18 ## # ... with 341 more rows 2.3.2 変数名の最後の文字列 _mmで終わる変数を選ぶ mmだけだと他にも含まれる場合が出てくるので，_も含めた方が安全 df %&gt;% select(ends_with(&quot;_mm&quot;)) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 2.3.3 変数名のどこかに含まれる文字列 2.3.3.1 固定した文字列 指定した文字列を含んだ変数名を対象とする df %&gt;% select(contains(&quot;length&quot;)) ## # A tibble: 344 x 2 ## bill_length_mm flipper_length_mm ## &lt;dbl&gt; &lt;int&gt; ## 1 39.1 181 ## 2 39.5 186 ## 3 40.3 195 ## # ... with 341 more rows 2.3.3.2 柔軟な文字列 文字列で 正規表現 が使えるため柔軟な指定が可能 ここでは，“length”または”depth”を含む変数名を対象 |が「または」を意味する df %&gt;% select(matches(&quot;length|depth&quot;)) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 2.3.4 上記の組み合わせ 2.3.4.1 かつ それぞれの条件を両方満たす df %&gt;% select(starts_with(&quot;bill&quot;) &amp; contains(&quot;length&quot;)) ## # A tibble: 344 x 1 ## bill_length_mm ## &lt;dbl&gt; ## 1 39.1 ## 2 39.5 ## 3 40.3 ## # ... with 341 more rows 2.3.4.2 または それぞれの条件をいずれか満たす df %&gt;% select(starts_with(&quot;bill&quot;) | contains(&quot;length&quot;)) ## # A tibble: 344 x 3 ## bill_length_mm bill_depth_mm flipper_length_mm ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 39.1 18.7 181 ## 2 39.5 17.4 186 ## 3 40.3 18 195 ## # ... with 341 more rows 2.3.5 [練習問題] dfデータで”s”で終わる変数を選んでデータフレームを表示させよう 2.4 特定の変数を選ばない（落とす） 変数名の前に!をつける df %&gt;% select(!species) ## # A tibble: 344 x 7 ## island bill_length_mm bill_depth_mm flipper_length_mm ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Torgersen 39.1 18.7 181 ## 2 Torgersen 39.5 17.4 186 ## 3 Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 複数列を落としたい場合は，!c( )の中に対象の列名を含める df %&gt;% select(!c(bill_length_mm:flipper_length_mm, sex)) ## # A tibble: 344 x 4 ## species island body_mass_g year ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torgersen 3750 2007 ## 2 Adelie Torgersen 3800 2007 ## 3 Adelie Torgersen 3250 2007 ## # ... with 341 more rows ヘルパー関数に対しても使える df %&gt;% select(!ends_with(&quot;_mm&quot;)) ## # A tibble: 344 x 5 ## species island body_mass_g sex year ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;fct&gt; &lt;int&gt; ## 1 Adelie Torgersen 3750 male 2007 ## 2 Adelie Torgersen 3800 female 2007 ## 3 Adelie Torgersen 3250 female 2007 ## # ... with 341 more rows 2.4.1 [練習問題] dfデータで”length”または”depth”を含む変数以外を選んでデータフレームを表示させよう 2.5 関心のある変数名を取得する データ分析の段階では，関心のある変数名を選択して，それらを代入する作業が頻出 変数名手打ちだと時間もかかるしミスもあるので，効率化のために必ずおさえておきたい技術 2.5.1 全ての変数名 df %&gt;% names() ## [1] &quot;species&quot; &quot;island&quot; &quot;bill_length_mm&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; &quot;year&quot; 2.5.2 選択した変数名を取得 ベクトルとしてオブジェクトに格納 bill_vars &lt;- df %&gt;% select(starts_with(&quot;bill&quot;)) %&gt;% names() bill_vars ## [1] &quot;bill_length_mm&quot; &quot;bill_depth_mm&quot; 2.5.3 コピペに便利な形式に出力 ,で区切られた形式で出てくれば必要なものを選んでそのままselect()に入れられるのに…と思った方のための便利関数dput() df %&gt;% select(starts_with(&quot;b&quot;)) %&gt;% # bから始まる変数名 names() %&gt;% dput() ## c(&quot;bill_length_mm&quot;, &quot;bill_depth_mm&quot;, &quot;body_mass_g&quot;) この出力から必要な変数を選んでコピペができる names()で出てくるのと違い，,がついているのが地味にうれしい \" \"すらもいらない，という時は，新しくr script(アイコンNew Fileまたはctrl + shift + n)開いて，dput()の出力を貼り付けてすべて置換する力技も "],["rename.html", "3 変数名を変更する：rename 3.1 基本 3.2 同じ語を共通の語で置き換える 3.3 同じ語を削除する 3.4 同じ接尾辞をつける", " 3 変数名を変更する：rename パッケージdplyrの関数rename() tidyな世界では「列名 = 変数名」 分かりやすい列名にすることだけでなく，本書の範囲を超えるが複数データの連結や同時処理関連で重要な役割を果たす 3.1 基本 まずはデータにどういう変数名があるかの確認 df %&gt;% names() ## [1] &quot;species&quot; &quot;island&quot; &quot;bill_length_mm&quot; ## [4] &quot;bill_depth_mm&quot; &quot;flipper_length_mm&quot; &quot;body_mass_g&quot; ## [7] &quot;sex&quot; &quot;year&quot; 変更したい変数名を new = old の順に入力する ここではbill_length_mmをblmmに変更してみる df %&gt;% rename(blmm = bill_length_mm) ## # A tibble: 344 x 8 ## species island blmm bill_depth_mm flipper_length_~ body_mass_g ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 Adelie Torge~ 39.1 18.7 181 3750 ## 2 Adelie Torge~ 39.5 17.4 186 3800 ## 3 Adelie Torge~ 40.3 18 195 3250 ## # ... with 341 more rows, and 2 more variables: sex &lt;fct&gt;, ## # year &lt;int&gt; 複数の変数名を変更する場合は，rename()の中に,でつなげていく でもたくさんある場合に一つ一つ書いていくのは大変 df %&gt;% rename(blmm = bill_length_mm, bdmm = bill_depth_mm) ## # A tibble: 344 x 8 ## species island blmm bdmm flipper_length_~ body_mass_g sex ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;fct&gt; ## 1 Adelie Torgers~ 39.1 18.7 181 3750 male ## 2 Adelie Torgers~ 39.5 17.4 186 3800 fema~ ## 3 Adelie Torgers~ 40.3 18 195 3250 fema~ ## # ... with 341 more rows, and 1 more variable: year &lt;int&gt; 複数変数を扱うときはrename_with()が便利。以下はそれを用いた例を示していく 3.2 同じ語を共通の語で置き換える 変数名の”bill”の部分を日本語の”くちばし”に変更していく まずは基本の知識でできる方法 df %&gt;% rename(くちばし_length_mm = bill_length_mm, くちばし_depth_mm = bill_depth_mm) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.2.1 【効率化】str_replace( )で一括変換(1) rename_with( )は，まず適用したい関数を示し，そのあとに該当する変数を選ぶ 語の置き換えにstringr::str_replace()を使う 第一引数に対して，その次の文字列をその後の文字列に置換する（ここでは”bill” → “くちばし”） 適用したい関数の中にある.xの部分に，その後選ぶ変数が入っていく(なおこのような単純な場合は.だけでも動く） この場合適用したい関数の前には~（チルダ）が必ずつく この部分の理解は今すぐできなくても使えるが，キーワードだけ示しておくと，無名関数(anonymous function)という処理をしている df %&gt;% rename_with(~str_replace(.x, &quot;bill&quot;, &quot;くちばし&quot;), starts_with(&quot;bill&quot;)) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.2.1.1 【別解】 selectのように単にc( )の中に変数を指定していくだけでも動く df %&gt;% rename_with(~str_replace(., &quot;bill&quot;, &quot;くちばし&quot;), c(bill_length_mm, bill_depth_mm)) ## # A tibble: 344 x 8 ## species island くちばし_length_mm くちばし_depth_mm ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 341 more rows, and 4 more variables: ## # flipper_length_mm &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; 3.3 同じ語を削除する “_mm”を取り除きたい場合，それを削除した変数名を指定すればよいが，たくさんあると大変 df %&gt;% rename(bill_length = bill_length_mm, bill_depth = bill_depth_mm, flipper_length = flipper_length_mm) ## # A tibble: 344 x 8 ## species island bill_length bill_depth flipper_length ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 3.3.1 【効率化】str_replace( )で一括変換（2） str_replace( )で変換先に空白\"\"を指定すると削除できる df %&gt;% rename_with(~str_replace(., &quot;_mm&quot;, &quot;&quot;), ends_with(&quot;mm&quot;)) ## # A tibble: 344 x 8 ## species island bill_length bill_depth flipper_length ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 3.3.1.1 【別解】 stringr::str_remove( )の方が直接的 第一引数についてその次に来る文字列を取り除く df %&gt;% rename_with(~str_remove(., &quot;_mm&quot;), ends_with(&quot;mm&quot;)) ## # A tibble: 344 x 8 ## species island bill_length bill_depth flipper_length ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 Adelie Torgersen 39.1 18.7 181 ## 2 Adelie Torgersen 39.5 17.4 186 ## 3 Adelie Torgersen 40.3 18 195 ## # ... with 341 more rows, and 3 more variables: ## # body_mass_g &lt;int&gt;, sex &lt;fct&gt;, year &lt;int&gt; 3.4 同じ接尾辞をつける 変数yearで2007年のみのデータに限定し，くちばし（bill）と翼（flipper）の変数名の末に”_2007”をつける renameの中に全部書いていけばできるが数が多いと大変 df %&gt;% filter(year == 2007) %&gt;% select(bill_length_mm:flipper_length_mm, year) %&gt;% rename(bill_length_mm_2007 = bill_length_mm, bill_depth_mm_2007 = bill_depth_mm, flipper_length_mm_2007 = flipper_length_mm) ## # A tibble: 110 x 4 ## bill_length_mm_2007 bill_depth_mm_2007 flipper_length_mm~ year ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 39.1 18.7 181 2007 ## 2 39.5 17.4 186 2007 ## 3 40.3 18 195 2007 ## # ... with 107 more rows 3.4.1 【効率化】str_c( )で一括指定 適用したい関数の中にある.の部分に，その後選ぶ変数が入っていく stringr::str_c()で指定した語をくっつける ここでは変数year以外すべてなので，yearに!をつけることで変数を指定できる df %&gt;% filter(year == 2007) %&gt;% select(bill_length_mm:flipper_length_mm, year) %&gt;% rename_with(~str_c(., &quot;_2007&quot;), !year) ## # A tibble: 110 x 4 ## bill_length_mm_2007 bill_depth_mm_2007 flipper_length_mm~ year ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 39.1 18.7 181 2007 ## 2 39.5 17.4 186 2007 ## 3 40.3 18 195 2007 ## # ... with 107 more rows 3.4.1.1 【別解】 変数を選ぶときに該当する単語を持つ変数を選びたければ，ヘルパー関数matches( )で正規表現を使って柔軟に選べる df %&gt;% filter(year == 2007) %&gt;% rename_with(~str_c(., &quot;_2007&quot;), matches(&quot;bill|flipper&quot;)) ## # A tibble: 110 x 8 ## species island bill_length_mm_2007 bill_depth_mm_2007 ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie Torgersen 39.1 18.7 ## 2 Adelie Torgersen 39.5 17.4 ## 3 Adelie Torgersen 40.3 18 ## # ... with 107 more rows, and 4 more variables: ## # flipper_length_mm_2007 &lt;int&gt;, body_mass_g &lt;int&gt;, sex &lt;fct&gt;, ## # year &lt;int&gt; "],["filter.html", "4 行（ケース）を選ぶ：filter 4.1 使用データ 4.2 基本 4.3 複数条件 4.4 キーワードによる検索", " 4 行（ケース）を選ぶ：filter パッケージdplyrの関数filter() tidyな世界では「行 = ケース, 個人（wide形式の場合）」 ケースが多い時に関心あるケースに限定したデータにしたい データフレームとして出力した結果を限定して見るときに使うことが多い気がする 4.1 使用データ dplyr::starwarsデータを使用 スターウォーズのキャラクターのデータ。filter( )のヘルプでも例に使用されている 身長や質量(mass)の連続量データに加え，色や種(species)など豊富なカテゴリを持つ変数がある starwars ## # A tibble: 87 x 14 ## name height mass hair_color skin_color eye_color birth_year ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Luke S~ 172 77 blond fair blue 19 ## 2 C-3PO 167 75 &lt;NA&gt; gold yellow 112 ## 3 R2-D2 96 32 &lt;NA&gt; white, bl~ red 33 ## # ... with 84 more rows, and 7 more variables: sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt;, species &lt;chr&gt;, films &lt;list&gt;, ## # vehicles &lt;list&gt;, starships &lt;list&gt; 例示しやすくするため種を先頭にしたデータを作成 df_st &lt;- starwars %&gt;% select(species, name:homeworld) 4.2 基本 filter( )の引数に論理式（TRUE or FALSEになるもの）を入れる 論理式の部分について，最初の内はselect( )に入れるものと違って混乱するかもしれない 例：種（species）が”Droid”のケースのみ選ぶ イコールを表すときは=を2つつなげる df_st %&gt;% filter(species == &quot;Droid&quot;) ## # A tibble: 6 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Droid C-3PO 167 75 &lt;NA&gt; gold yellow ## 2 Droid R2-D2 96 32 &lt;NA&gt; white, blue red ## 3 Droid R5-D4 97 32 &lt;NA&gt; white, red red ## 4 Droid IG-88 200 140 none metal red ## 5 Droid R4-P17 96 NA none silver, red red, blue ## 6 Droid BB8 NA NA none none black ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; 例：身長（height）が200以上のケースのみ選ぶ df_st %&gt;% filter(height &gt;= 200) ## # A tibble: 11 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Human Darth ~ 202 136 none white yellow ## 2 Wookiee Chewba~ 228 112 brown unknown blue ## 3 Droid IG-88 200 140 none metal red ## 4 Gungan Roos T~ 224 82 none grey orange ## 5 Gungan Rugor ~ 206 NA none green orange ## 6 Quermian Yarael~ 264 NA none white yellow ## 7 Kaminoan Lama Su 229 88 none grey black ## 8 Kaminoan Taun We 213 NA none grey black ## 9 Kaleesh Grievo~ 216 159 none brown, whi~ green, y~ ## 10 Wookiee Tarfful 234 136 brown brown blue ## 11 Pau&#39;an Tion M~ 206 80 none grey black ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; ～以外を表すときは!をつけ，この場合は=は1つでよい 例：種がHumanのケース以外を選ぶ df_st %&gt;% filter(species != &quot;Human&quot;) ## # A tibble: 48 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Droid C-3PO 167 75 &lt;NA&gt; gold yellow ## 2 Droid R2-D2 96 32 &lt;NA&gt; white, blue red ## 3 Droid R5-D4 97 32 &lt;NA&gt; white, red red ## # ... with 45 more rows, and 4 more variables: birth_year &lt;dbl&gt;, ## # sex &lt;chr&gt;, gender &lt;chr&gt;, homeworld &lt;chr&gt; 4.2.1 欠損値（NA）の扱い 現実のデータでは，データが入手できない対象が発生することも多く，変数の値の中にデータがない変数の行（excel風にいうとセル）が発生する Rではデータのない部分，いわゆる欠損値はNAで表される 例：種がNAのケースを選ぶ NAかどうかを判定する論理式はis.na( ) df_st %&gt;% filter(is.na(species)) ## # A tibble: 4 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 &lt;NA&gt; Ric Olie 183 NA brown fair blue ## 2 &lt;NA&gt; Quarsh Pa~ 183 NA black dark brown ## 3 &lt;NA&gt; Sly Moore 178 48 none pale white ## 4 &lt;NA&gt; Captain P~ NA NA unknown unknown unknown ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; 4.2.2 [練習問題] df_stのデータから変数”hair_color”の値が”white”のケースを選ぼう df_stのデータから変数”mass”の値が40未満のケースを選ぼう 4.3 複数条件 例：種がDroidまたはHumanのケースを選ぶ |は「または」を表す df_st %&gt;% filter(species == &quot;Droid&quot; | species == &quot;Human&quot;) ## # A tibble: 41 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Human Luke Skyw~ 172 77 blond fair blue ## 2 Droid C-3PO 167 75 &lt;NA&gt; gold yellow ## 3 Droid R2-D2 96 32 &lt;NA&gt; white, bl~ red ## # ... with 38 more rows, and 4 more variables: birth_year &lt;dbl&gt;, ## # sex &lt;chr&gt;, gender &lt;chr&gt;, homeworld &lt;chr&gt; 種がDroidかつ身長が100未満のケースのみ選ぶ &amp;は「かつ」を表す df_st %&gt;% filter(species == &quot;Droid&quot; &amp; height &lt; 100) ## # A tibble: 3 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Droid R2-D2 96 32 &lt;NA&gt; white, blue red ## 2 Droid R5-D4 97 32 &lt;NA&gt; white, red red ## 3 Droid R4-P17 96 NA none silver, red red, blue ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; 4.3.1 【効率化】 選びたいものが多くなると，書くのが大変。“species ==”とかをいちいち書きたくない 例: 種で”Aleena”または “Dug”または “Yoda’s species”を選びたいとき df_st %&gt;% filter(species == &quot;Aleena&quot; | species == &quot;Dug&quot; | species == &quot;Yoda&#39;s species&quot;) ## # A tibble: 3 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Yoda&#39;s sp~ Yoda 66 17 white green brown ## 2 Dug Sebulba 112 40 none grey, red orange ## 3 Aleena Ratts ~ 79 15 none grey, blue unknown ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; %in%で解決 df_st %&gt;% filter(species %in% c(&quot;Aleena&quot;, &quot;Dug&quot;, &quot;Yoda&#39;s species&quot;)) ## # A tibble: 3 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Yoda&#39;s sp~ Yoda 66 17 white green brown ## 2 Dug Sebulba 112 40 none grey, red orange ## 3 Aleena Ratts ~ 79 15 none grey, blue unknown ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; 例: 種で”Droid”, “Human”以外を選びたいとき この場合，&amp;が必須 df_st %&gt;% filter(species != &quot;Droid&quot; &amp; species != &quot;Human&quot;) ## # A tibble: 42 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Wookiee Chewbacca 228 112 brown unknown blue ## 2 Rodian Greedo 173 74 &lt;NA&gt; green black ## 3 Hutt Jabba De~ 175 1358 &lt;NA&gt; green-tan,~ orange ## # ... with 39 more rows, and 4 more variables: birth_year &lt;dbl&gt;, ## # sex &lt;chr&gt;, gender &lt;chr&gt;, homeworld &lt;chr&gt; 変数の前に!をつけるだけで省略できる df_st %&gt;% filter(!species %in% c(&quot;Droid&quot;, &quot;Human&quot;)) ## # A tibble: 46 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Wookiee Chewbacca 228 112 brown unknown blue ## 2 Rodian Greedo 173 74 &lt;NA&gt; green black ## 3 Hutt Jabba De~ 175 1358 &lt;NA&gt; green-tan,~ orange ## # ... with 43 more rows, and 4 more variables: birth_year &lt;dbl&gt;, ## # sex &lt;chr&gt;, gender &lt;chr&gt;, homeworld &lt;chr&gt; 4.3.2 [練習問題] df_stのデータから変数”species”の値が”Human”かつ変数”sex”の値が”female”のケースを選ぼう df_stのデータから変数”eye_color”の値が”blue-gray”または”dark”または”gold”または”pink”のケースを効率化した方法で選ぼう 4.4 キーワードによる検索 手元で特定の名前の行のデータを見たいときに便利 キーワード検索には，正規表現の結果をTRUE or FALSEで返す関数stringr::str_detect( )を使う 例：変数nameに”Luke”を含む行を見たい df_st %&gt;% filter(str_detect(name, &quot;Luke&quot;)) ## # A tibble: 1 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Human Luke Skyw~ 172 77 blond fair blue ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; 例：変数nameが”R”で始まる行を見たい 正規表現で^はその次の文字から始まる文字列という意味 df_st %&gt;% filter(str_detect(name, &quot;^R&quot;)) ## # A tibble: 9 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Droid R2-D2 96 32 &lt;NA&gt; white, bl~ red ## 2 Droid R5-D4 97 32 &lt;NA&gt; white, red red ## 3 Gungan Roos Tarp~ 224 82 none grey orange ## 4 Gungan Rugor Nass 206 NA none green orange ## 5 &lt;NA&gt; Ric Olie 183 NA brown fair blue ## 6 Aleena Ratts Tye~ 79 15 none grey, blue unknown ## 7 Droid R4-P17 96 NA none silver, r~ red, blue ## 8 Human Raymus An~ 188 79 brown light brown ## 9 Human Rey NA NA brown light hazel ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; 例：変数nameが”Y”または”L”で始まる行を見たい 正規表現で「または」は\" \"の中に入れる df_st %&gt;% filter(str_detect(name, &quot;^Y|^L&quot;)) ## # A tibble: 8 x 11 ## species name height mass hair_color skin_color eye_color ## &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Human Luke Sk~ 172 77 blond fair blue ## 2 Human Leia Or~ 150 49 brown light brown ## 3 Yoda&#39;s s~ Yoda 66 17 white green brown ## 4 Human Lando C~ 177 79 black dark brown ## 5 Human Lobot 175 79 none light blue ## 6 Quermian Yarael ~ 264 NA none white yellow ## 7 Mirialan Luminar~ 170 56.2 black yellow blue ## 8 Kaminoan Lama Su 229 88 none grey black ## # ... with 4 more variables: birth_year &lt;dbl&gt;, sex &lt;chr&gt;, ## # gender &lt;chr&gt;, homeworld &lt;chr&gt; "],["mutate.html", "5 新しい変数（列）の作成：mutate 5.1 使用データ 5.2 基本 5.3 変数の型の変換 5.4 across( )の特徴 5.5 合計点の作成 5.6 変数の値を数値から文字列に変える 5.7 連番からIDの作成 5.8 逆転項目を作る 5.9 【別解】合計点の作成 5.10 連続変数をカテゴリに区分する", " 5 新しい変数（列）の作成：mutate パッケージdplyrの関数mutate() 新しい変数の列を作成する 効率化のためのacross() 5.1 使用データ psychToolsパッケージに入っている国際パーソナリティ項目プールからの2800名分のデータ 質問項目が25問あり，5つの構成概念（ここでは因子という）に対応する項目への回答を足し合わせたスコアを計算する 性，教育歴，年齢の変数もあり 項目に対し想定される因子（因子名の頭文字が変数名と対応） Agree A1からA5 Conscientious C1からC5 Extraversion E1からE5 Neuroticism N1からN5 Openness O1からO5 回答選択肢 1 Very Inaccurate まったくあてはまらない 2 Moderately Inaccurate あてはまらない 3 Slightly Inaccurate ややあてはまらない 4 Slightly Accurate ややあてはまる 5 Moderately Accurate あてはまる 6 Very Accurate 非常にあてはまる # パッケージが入ってなければ下記の#を外して実行 # install.packages(&quot;psychTools&quot;) df_bfi &lt;- psychTools::bfi %&gt;% as_tibble() # 表示に便利なtibble形式に 5.2 基本 データフレームに新しい列を計算して追加するまたは置き換える関数 mutate( )の中に新しく作成する変数名を入れ，=でつないで計算式を入れる ここでは，まず変数A1の平均値（全ケース同じ値が入る）を計算し，個々のケースの値の差分を新しく列として追加する例を示す df_bfi %&gt;% select(A1) %&gt;% # A1のみを残す mutate( mean_a1 = mean(A1, na.rm = TRUE), # A1の平均値を作成（NAは除外） dif_a1_mean = A1 - mean_a1) # 各個体のA1と平均値の差分を計算 ## # A tibble: 2,800 x 3 ## A1 mean_a1 dif_a1_mean ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 2.41 -0.413 ## 2 2 2.41 -0.413 ## 3 5 2.41 2.59 ## # ... with 2,797 more rows mean_a1列にはA1の平均値がすべて同じ値で入る（平均値だけの計算がしたければ6章を参照） dif_a1_mean列は，A1列からmean_a1列を引いた値が入る 5.3 変数の型の変換 変数には型の情報が伴い，統計解析やデータ加工の際に適切な型を求められることがあるため理解が必要 小数も扱う数値（double-precision） &lt;dbl&gt; 整数 &lt;int&gt; 文字 &lt;chr&gt; 因子 &lt;fct&gt; 変数の型の確認は色々方法があるが，tibble形式のデータフレームならselect()でOK df_bfi %&gt;% select(gender, education) ## # A tibble: 2,800 x 2 ## gender education ## &lt;int&gt; &lt;int&gt; ## 1 1 NA ## 2 2 NA ## 3 2 NA ## # ... with 2,797 more rows tibble形式でない普通のデータフレームでも，最後にglimpse()で出力することで型を確認可能 df_bfi %&gt;% select(gender, education) %&gt;% glimpse() ## Rows: 2,800 ## Columns: 2 ## $ gender &lt;int&gt; 1, 2, 2, 2, 1, 2, 1, 1, 1, 2, 1, 1, 2, 1, 1, ~ ## $ education &lt;int&gt; NA, NA, NA, NA, NA, 3, NA, 2, 1, NA, 1, NA, N~ glimpse()の結果はデータフレームの表示が行列入れ替わっており，変数の情報が行ごとに出力される gender, education列が &lt;int&gt; になっているので整数型になっている 5.3.1 型の変換 ここでは，2つの数値型変数gender, educationを因子型に変換する例を示す それぞれfactor()で因子型に変換 df_bfi %&gt;% select(gender, education) %&gt;% mutate(gender = factor(gender), education = factor(education)) ## # A tibble: 2,800 x 2 ## gender education ## &lt;fct&gt; &lt;fct&gt; ## 1 1 &lt;NA&gt; ## 2 2 &lt;NA&gt; ## 3 2 &lt;NA&gt; ## # ... with 2,797 more rows gender, education列が &lt;fct&gt; になっているので整数型になっている 5.3.2 【効率化】複数の変数に対し一度の指定で実行 変換したい変数が大量にあるときは上記の方法では大変 across()を使うと，指定した変数に対して同じ内容の処理なら 1回 ですむようになる かつてはmutate_at( ), mutate_if( ), mutate_all( )など別々の関数だったが，across( )の登場で統一的にmutate( )内で扱えるようになった df_bfi %&gt;% mutate(across(c(gender, education), factor)) %&gt;% select(gender, education) # 結果表示のため冗長だが変わった変数だけselect ## # A tibble: 2,800 x 2 ## gender education ## &lt;fct&gt; &lt;fct&gt; ## 1 1 &lt;NA&gt; ## 2 2 &lt;NA&gt; ## 3 2 &lt;NA&gt; ## # ... with 2,797 more rows 5.4 across( )の特徴 変数の指定に2.3で解説したヘルパー関数が使える df_bfi %&gt;% mutate(across(starts_with(&quot;n&quot;), factor)) %&gt;% select(starts_with(&quot;n&quot;)) # 結果表示のため ## # A tibble: 2,800 x 5 ## N1 N2 N3 N4 N5 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 3 4 2 2 3 ## 2 3 3 3 5 5 ## 3 4 5 4 2 3 ## # ... with 2,797 more rows 同じく2.2.3で解説した文字型の変数名も指定に使える vars &lt;- c(&quot;N1&quot;, &quot;N2&quot;, &quot;N3&quot;, &quot;N4&quot;, &quot;N5&quot;) df_bfi %&gt;% mutate(across(all_of(vars), factor)) %&gt;% select(starts_with(&quot;n&quot;)) # 結果表示のため ## # A tibble: 2,800 x 5 ## N1 N2 N3 N4 N5 ## &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; &lt;fct&gt; ## 1 3 4 2 2 3 ## 2 3 3 3 5 5 ## 3 4 5 4 2 3 ## # ... with 2,797 more rows 5.4.1 【重要知識】新しい変数名にして追加 ここはこの後色々なところで出てくる方法のため理解しておきたい 適用する関数をリストにする（list()に入れる）ことで，変数名を変更して追加できる list()に入れるときはこれまでと異なる書き方が必要になる 関数名の前に~（チルダ）が必要（3.2.1参照） list内の関数()内に.xが必要。ここにacross()の第一引数に指定した変数が入っていくという意味 例：genderとeducationの型を因子型に変換し，変換前後で変わっているかどうか確認 df_bfi %&gt;% mutate(across(c(gender, education), list(f = ~factor(.x)))) %&gt;% select(matches(&quot;gender|education&quot;)) ## # A tibble: 2,800 x 4 ## gender education gender_f education_f ## &lt;int&gt; &lt;int&gt; &lt;fct&gt; &lt;fct&gt; ## 1 1 NA 1 &lt;NA&gt; ## 2 2 NA 2 &lt;NA&gt; ## 3 2 NA 2 &lt;NA&gt; ## # ... with 2,797 more rows 因子型に変換した変数の末尾に_fがつく 5.5 合計点の作成 変数の四則演算の式を入れれば合計得点として計算された列をデータフレームに追加できる df_bfi_n &lt;- df_bfi %&gt;% select(N1:N5) %&gt;% mutate(neuroticism = N1 + N2 + N3 + N4 + N5) df_bfi_n ## # A tibble: 2,800 x 6 ## N1 N2 N3 N4 N5 neuroticism ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 3 4 2 2 3 14 ## 2 3 3 3 5 5 19 ## 3 4 5 4 2 3 18 ## # ... with 2,797 more rows 別解として，変数の逆転項目を反映させた後に， 5.9 で異なるやり方で合計した例を解説する 項目数が多い場合などはこちらの方が効率化できる場合も 5.5.1 足し上げる変数に欠損値があるとどうなるか 欠損値については4.2.1参照 合計得点の計算の場合，対象となる変数の内1つでもNAがあれば合計点もNAとなる df_bfi_n %&gt;% filter(is.na(neuroticism)) # neuroticismがNAなケースに限定 ## # A tibble: 106 x 6 ## N1 N2 N3 N4 N5 neuroticism ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 4 5 3 2 NA NA ## 2 NA 2 1 2 2 NA ## 3 1 2 1 2 NA NA ## # ... with 103 more rows 5.6 変数の値を数値から文字列に変える 一度因子型に変換してからforcatsパッケージのfct_recode( )関数を使うと簡単 例：genderの値1,2をそれぞれmale, femaleという文字に置き換える ちゃんと変換の対応がついているかどうかをdplyrパッケージのcount( )関数で確認 適切に変換されていなければ，1 = male, 2 = female以外の組み合わせも発生するため count( )の強みは，出力がデータフレームで出てくる点なので，結果が扱いやすい df_bfi %&gt;% mutate(gender = factor(gender), gender_c = fct_recode(gender, male = &quot;1&quot;, female = &quot;2&quot;)) %&gt;% count(gender, gender_c) ## # A tibble: 2 x 3 ## gender gender_c n ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; ## 1 1 male 919 ## 2 2 female 1881 5.7 連番からIDの作成 dplyr::row_number()で行番号からIDを作成 df_bfi_n %&gt;% mutate(id = row_number()) ## # A tibble: 2,800 x 7 ## N1 N2 N3 N4 N5 neuroticism id ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 3 4 2 2 3 14 1 ## 2 3 3 3 5 5 19 2 ## 3 4 5 4 2 3 18 3 ## # ... with 2,797 more rows 5.7.1 【別解】行の名前を直接変数化 実はmutateを使わなくてもできて，データの最初に持ってこれる便利関数がある tibble::rowid_to_column() var =で変数名を指定 df_bfi_n %&gt;% rowid_to_column(var = &quot;id&quot;) ## # A tibble: 2,800 x 7 ## id N1 N2 N3 N4 N5 neuroticism ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 1 3 4 2 2 3 14 ## 2 2 3 3 3 5 5 19 ## 3 3 4 5 4 2 3 18 ## # ... with 2,797 more rows # この先使わないのでデータフレーム削除 rm(df_bfi_n) 5.8 逆転項目を作る 心理尺度などの場合，質問内容に対する回答選択肢の意味が，項目間で逆になるように設定されることがあり，合計点などを作る際に尺度の意味を適切に表すように，取りうる数値の範囲内で値を入れ替える作業が発生することがある たとえば，感情の状態を項目を合計してたずねる尺度で，「いつも楽しい」という項目と，「いつも悲しい」という聞き方をしていたら，それぞれの回答を得点化したときに意味が反対になるため，同じ方向になるようにする必要がある 例：「1. まったくあてはまらない ←→ 6. 非常にあてはまる」のルールを「いつも悲しい」項目に適用し，1の回答を6に置き換えれば，「いつも楽しい」とポジティブな方向で点数の意味がそろう 5.8.1 逆転項目の確認 bfiデータの場合，どの項目を逆転する必要があるかを示す情報（-変数名で表現）がパッケージに含まれている psychTools::bfi.keys で確認可能 したがって，“-A1”, “-C4”, “-C5”, “-E1”, “-E2”, “-O2”, “-O5”が対象 5.8.2 逆転：recode dplyr::recode()を使用 対象の変数をrecode( )の第一引数に，入れ替えたい値をold = newで並べていく この等式の順番が他(mutateなど)と逆になるため，recode()は将来引退する可能性ありとされている また，下記のように考慮すべき点があるから，後述の5.8.3【別解】を使う方がよいかもしれない 値の指定で考慮すべき点 oldの数値はで囲む必要がある newの数値にLがつくのは，型を整数のままにするため df_bfi %&gt;% mutate(A1_r = recode(A1, `1` = 6L, `2` = 5L, `3` = 4L, `4` = 3L, `5` = 2L, `6` = 1L)) %&gt;% select(A1, A1_r) ## # A tibble: 2,800 x 2 ## A1 A1_r ## &lt;int&gt; &lt;int&gt; ## 1 2 5 ## 2 2 5 ## 3 5 2 ## # ... with 2,797 more rows 5.8.2.1 変数2つ以上を逆転 A1と同様に同じ形をくり返し変数名だけ変えていけばできるが，コードが長くなりミスも生じやすくなる df_bfi %&gt;% mutate(A1_r = recode(A1, `1` = 6L, `2` = 5L, `3` = 4L, `4` = 3L, `5` = 2L, `6` = 1L), C4_r = recode(C4, `1` = 6L, `2` = 5L, `3` = 4L, `4` = 3L, `5` = 2L, `6` = 1L)) %&gt;% select(A1, A1_r, C4, C4_r) ## # A tibble: 2,800 x 4 ## A1 A1_r C4 C4_r ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2 5 4 3 ## 2 2 5 3 4 ## 3 5 2 2 5 ## # ... with 2,797 more rows 5.8.2.2 【効率化】 変数2つ以上を逆転 5.4.1 で解説したlistに関数を入れる方法 これで対象となるacross( )内変数に_rの接尾辞が付いた逆転項目が追加される df_bfi %&gt;% mutate(across(c(A1, C4, C5, E1, E2, O2, O5), list(r = ~recode(.x, `1` = 6, `2` = 5, `3` = 4, `4` = 3, `5` = 2, `6` = 1)))) %&gt;% select(A1, A1_r, C4, C4, C5, C5_r, E1, E1_r, E2, E2_r, O2, O2_r, O5, O5_r) ## # A tibble: 2,800 x 13 ## A1 A1_r C4 C5 C5_r E1 E1_r E2 E2_r O2 ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2 5 4 4 3 3 4 3 4 6 ## 2 2 5 3 4 3 1 6 1 6 2 ## 3 5 2 2 5 2 2 5 4 3 2 ## # ... with 2,797 more rows, and 3 more variables: O2_r &lt;dbl&gt;, ## # O5 &lt;int&gt;, O5_r &lt;dbl&gt; 5.8.3 【別解】逆転（公式） 項目を反転する公式が「(max + min) - 回答値」であることを利用 psych::reverse.code()のhelp参照 例：最小値1,最大値4の場合，max + min = 5となり，回答値が2の場合，5 - 2 = 3となり反転された結果となる min &lt;- 1 max &lt;- 6 df_bfi %&gt;% mutate(A1_r = max + min - A1, C4_r = max + min - C4) %&gt;% select(A1, A1_r, C4, C4_r) ## # A tibble: 2,800 x 4 ## A1 A1_r C4 C4_r ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 5 4 3 ## 2 2 5 3 4 ## 3 5 2 2 5 ## # ... with 2,797 more rows 5.8.3.1 【効率化】 変数2つ以上を逆転 ~の後に計算式がきても動く ここでは，max + min - .x の.xにacross()内に置かれた変数が入っていく df_bfi %&gt;% mutate(across(c(A1,C4), list(r = ~ max + min - .x))) %&gt;% select(A1, A1_r, C4, C4_r) ## # A tibble: 2,800 x 4 ## A1 A1_r C4 C4_r ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 5 4 3 ## 2 2 5 3 4 ## 3 5 2 2 5 ## # ... with 2,797 more rows 5.8.3.2 逆転した変数を含むデータフレーム作成 これ以降で使用するため，項目を逆転した変数を格納しておく df_bfi &lt;- df_bfi %&gt;% mutate(across(c(A1, C4, C5, E1, E2, O2, O5), list(r = ~ max + min - .x))) 5.9 【別解】合計点の作成 base::rowSums( ) データフレームで行の単位で総計するので，行（ケース）ごとに合計点を作成できる まず総計の対象となる変数名を2.2.3で解説したように文字ベクトルにしていく rowSums( )の中でacross( )が使えるので，あとは定義した項目のオブジェクトを指定していくだけ # 合計する項目の定義 Ag &lt;- df_bfi %&gt;% select(A1_r, A2:A5) %&gt;% names() Co &lt;- df_bfi %&gt;% select(C1:C3, C4_r, C5_r) %&gt;% names() Ex &lt;- df_bfi %&gt;% select(E1_r, E2_r, E3:E5) %&gt;% names() Ne &lt;- df_bfi %&gt;% select(N1:N5) %&gt;% names() Op &lt;- df_bfi %&gt;% select(O1, O2_r, O3, O4, O5_r) %&gt;% names() df_bfi &lt;- df_bfi %&gt;% mutate( Agree = rowSums(across(all_of(Ag))), Conscientious = rowSums(across(all_of(Co))), Extraversion = rowSums(across(all_of(Ex))), Neuroticism = rowSums(across(all_of(Ne))), Openness = rowSums(across(all_of(Op))) ) 5.9.1 【確認】 変数の中にNAが入る場合は合計もNAになる。 rowSums(across(all_of(Op)), na.rm = TRUE)と引数を追加すれば，NAを無視して合計できる df_bfi %&gt;% select(all_of(Ag), Agree) ## # A tibble: 2,800 x 6 ## A1_r A2 A3 A4 A5 Agree ## &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 5 4 3 4 4 20 ## 2 5 4 5 2 5 21 ## 3 2 4 5 4 4 19 ## # ... with 2,797 more rows df_bfi %&gt;% select(all_of(Ex), Extraversion) %&gt;% filter(is.na(Extraversion)) ## # A tibble: 87 x 6 ## E1_r E2_r E3 E4 E5 Extraversion ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2 4 NA 4 3 NA ## 2 6 6 4 4 NA NA ## 3 2 NA 3 2 3 NA ## # ... with 84 more rows rowSums( )をbase::rowMeans( )に変えれば平均値も計算できる 5.10 連続変数をカテゴリに区分する 5.10.1 分布の把握 変数ageのヒストグラムを描き，分布を確認する グラフ作成パッケージggplot2でどんなグラフが作れるかは著者作成の辞書参照 ggplot2の辞書 ggplot(df_bfi) + # ここにデータフレーム geom_histogram(aes(age)) # aes( )の中に対象変数 さっと中央値だけ見たいのであれば，従来のRの書き方が早い 役に立つ場面が多いので，慣れたら従来の書き方を学んでおくとよい データフレーム$変数名と指定することで変数として扱える # 中央値 median(df_bfi$age) ## [1] 26 # モダンな方法だと少し長くなる # df_bfi %&gt;% # summarise(median(age)) 5.10.2 2区分 dplyr::if_else( )で条件式（TRUEまたはFALSEを返すもの）によって値を2区分する 構造：if_else(条件式, TRUEの場合の値, FALSEの場合の値) TRUEの場合の値, FALSEの場合の値はそれぞれ文字型を入れることもできる（例:“27歳以上”, “27歳未満”） res_age2 &lt;- df_bfi %&gt;% mutate(age2 = if_else(age &gt;= 27, 1, 0)) %&gt;% select(age, age2) res_age2 %&gt;% count(age2) ## # A tibble: 2 x 2 ## age2 n ## &lt;dbl&gt; &lt;int&gt; ## 1 0 1495 ## 2 1 1305 5.10.2.1 確認 age &gt;= 27が1，27未満が0にコーディングされているかfilter( )で限定して確認 res_age2 %&gt;% filter(age &gt;= 20 &amp; age &lt;= 30) %&gt;% count(age, age2) %&gt;% print(n = 11) ## # A tibble: 11 x 3 ## age age2 n ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 20 0 212 ## 2 21 0 144 ## 3 22 0 122 ## 4 23 0 138 ## 5 24 0 105 ## 6 25 0 113 ## 7 26 0 99 ## 8 27 1 97 ## 9 28 1 86 ## 10 29 1 78 ## 11 30 1 65 念のため最初3行（1-3行目）と最後3行（n-2行目からn行目）も確認 dplyr::slice( )で1:3行目と最後の3行を表示させる res_age2 %&gt;% count(age, age2) %&gt;% slice(1:3, (n()-2):n()) ## # A tibble: 6 x 3 ## age age2 n ## &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 3 0 1 ## 2 9 0 1 ## 3 11 0 3 ## 4 72 1 1 ## 5 74 1 1 ## 6 86 1 1 rm(res_age2) 5.10.3 3区分以上 年齢層を10歳区切りでカテゴリ化 res_age6 &lt;- df_bfi %&gt;% mutate(age6 = case_when( age &lt; 20 ~ &quot;20歳未満&quot;, age &gt;= 20 &amp; age &lt; 30 ~ &quot;20-29歳&quot;, age &gt;= 30 &amp; age &lt; 40 ~ &quot;30-39歳&quot;, age &gt;= 40 &amp; age &lt; 50 ~ &quot;40-49歳&quot;, age &gt;= 50 &amp; age &lt; 60 ~ &quot;50-59歳&quot;, age &gt;= 60 ~ &quot;60歳以上&quot; )) # 確認するには以下のコードの最初の2行だけでよいが， # 出力が長いためランダムに10件抽出しageの昇順にしてある res_age6 %&gt;% count(age, age6) %&gt;% slice_sample(n = 10) %&gt;% # ランダムに10件抽出 arrange(age) # ageをキーに行を昇順にソート ## # A tibble: 10 x 3 ## age age6 n ## &lt;int&gt; &lt;chr&gt; &lt;int&gt; ## 1 17 20歳未満 100 ## 2 24 20-29歳 105 ## 3 33 30-39歳 50 ## 4 37 30-39歳 36 ## 5 41 40-49歳 32 ## 6 45 40-49歳 28 ## 7 51 50-59歳 24 ## 8 57 50-59歳 9 ## 9 62 60歳以上 4 ## 10 72 60歳以上 1 rm(res_age6) "],["summarise.html", "6 要約値を作る：summarise 6.1 基本 6.2 複数の計算 6.3 層別（グループ別）集計 6.4 【効率化】関数にする", " 6 要約値を作る：summarise パッケージdplyrの関数summarise() 結果をデータフレームとして出力するため，扱いが便利 データを知るうえで要約作業は頻繁に行うことが想定される 便利な要約パッケージが色々あるものの，summarise()を使いこなせると役に立つことが多い 6.1 基本 summarise( )の中に出力したい変数名を書き，=の後に計算する関数を入れる 例：bill_length_mmの平均値を算出する df %&gt;% summarise(blm_平均値 = mean(bill_length_mm, na.rm = TRUE)) ## # A tibble: 1 x 1 ## blm_平均値 ## &lt;dbl&gt; ## 1 43.9 6.2 複数の計算 複数の変数について平均値とSDとnを出したいときは，基本知識では全部書くので長くなる df %&gt;% summarise(blm_mean = mean(bill_length_mm, na.rm = TRUE), bdm_mean = mean(bill_depth_mm, na.rm = TRUE), blm_sd = sd(bill_length_mm, na.rm = TRUE), bdm_sd = sd(bill_depth_mm, na.rm = TRUE), blm_n = sum(!is.na(bill_length_mm)), bdm_n = sum(!is.na(bill_depth_mm))) ## # A tibble: 1 x 6 ## blm_mean bdm_mean blm_sd bdm_sd blm_n bdm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; ## 1 43.9 17.2 5.46 1.97 342 342 6.2.1 【効率化】 5.3.2で出てきたacross()がここでも有用 across()の第一引数に指定したい変数名ベクトル，またはヘルパー関数を入れる 実行したい関数をlist内に名前（接尾辞）をつけて列挙し，関数の前に~をつける sum(!is.na(.x))は，NAのない行の数を総計するので，平均値やSDの計算に用いた人数を取得できる df %&gt;% summarise(across(c(bill_length_mm, bill_depth_mm), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) ## # A tibble: 1 x 6 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 ## # ... with 3 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt;, bill_depth_mm_n &lt;int&gt; across()ではヘルパー関数が使える df %&gt;% summarise(across(starts_with(&quot;bill&quot;), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) ## # A tibble: 1 x 6 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 ## # ... with 3 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt;, bill_depth_mm_n &lt;int&gt; 6.2.2 【並び替え】 上記の出力は横に長いため見にくい tidyr::pivot_longer()で，データフレームの行列入れ替えができる 引数をnames_patternとnames_toを下記のように指定することで，変数の接尾辞を列名にできる 下記コードのsummarise( )部分の構造は前のチャンクと変数名以外同じ df %&gt;% summarise(across(bill_length_mm:body_mass_g, list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) %&gt;% pivot_longer(everything(), names_to = c(&quot;items&quot;, &quot;.value&quot;), # &quot;.value&quot;の部分を列名に names_pattern = &quot;(.*)_(.*)&quot;) # 正規表現 ## # A tibble: 4 x 4 ## items mean sd n ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 bill_length_mm 43.9 5.46 342 ## 2 bill_depth_mm 17.2 1.97 342 ## 3 flipper_length_mm 201. 14.1 342 ## 4 body_mass_g 4202. 802. 342 6.3 層別（グループ別）集計 group_by( )にグループを表す変数を指定するとできる df %&gt;% group_by(species) %&gt;% summarise(across(c(bill_length_mm, bill_depth_mm), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE)))) ## # A tibble: 3 x 5 ## species bill_length_mm_mean bill_length_mm_~ bill_depth_mm_m~ ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie 38.8 2.66 18.3 ## 2 Chinstrap 48.8 3.34 18.4 ## 3 Gentoo 47.5 3.08 15.0 ## # ... with 1 more variable: bill_depth_mm_sd &lt;dbl&gt; グループを重ねることも可能 df %&gt;% group_by(species, sex) %&gt;% summarise(across(c(bill_length_mm, bill_depth_mm), list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE)))) ## # A tibble: 8 x 6 ## # Groups: species [3] ## species sex bill_length_mm_mean bill_length_mm_sd ## &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Adelie female 37.3 2.03 ## 2 Adelie male 40.4 2.28 ## 3 Adelie &lt;NA&gt; 37.8 2.80 ## 4 Chinstrap female 46.6 3.11 ## 5 Chinstrap male 51.1 1.56 ## 6 Gentoo female 45.6 2.05 ## 7 Gentoo male 49.5 2.72 ## 8 Gentoo &lt;NA&gt; 45.6 1.37 ## # ... with 2 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt; 6.4 【効率化】関数にする 6.4.1 基本 自分で名づける関数名 &lt;- function(引数){ 計算式やコード } で関数を定義できる 例：関数の引数に数値を入れると+1した値を返す関数 add_one &lt;- function(x){ x + 1 } add_one(2) ## [1] 3 6.4.2 複数変数の平均値とSDとnを計算する関数 {{ }}はcurly curlyと読み，関数を作成するときに，代入先の変数名の場所を指定する時などに活躍 下記の例の場合，{{ }}を外すと動かない 例：引数にデータフレーム（data）と変数（vars）を入れると平均値とSDとnを返す関数 mean_sd_n &lt;- function(data, vars){ data %&gt;% summarise(across({{vars}}, list(mean = ~mean(.x, na.rm = TRUE), sd = ~sd(.x, na.rm = TRUE), n = ~sum(!is.na(.x))))) } ここで定義した関数mean_sd_n( )にデータフレームと変数を入れると結果が表示される mean_sd_n(df, bill_length_mm) ## # A tibble: 1 x 3 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 vasの部分はacross( )の第一引数に入れるものと同じ指定ができるため，変数ベクトルやヘルパー関数が入る # 変数ベクトル mean_sd_n(df, c(flipper_length_mm, body_mass_g)) ## # A tibble: 1 x 6 ## flipper_length_mm_mean flipper_length_mm_sd flipper_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 201. 14.1 342 ## # ... with 3 more variables: body_mass_g_mean &lt;dbl&gt;, ## # body_mass_g_sd &lt;dbl&gt;, body_mass_g_n &lt;int&gt; # 文字でも可能 # mean_sd_n(df, c(&quot;flipper_length_mm&quot;, &quot;body_mass_g&quot;)) # ヘルパー関数 mean_sd_n(df, starts_with(&quot;bill&quot;)) ## # A tibble: 1 x 6 ## bill_length_mm_mean bill_length_mm_sd bill_length_mm_n ## &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; ## 1 43.9 5.46 342 ## # ... with 3 more variables: bill_depth_mm_mean &lt;dbl&gt;, ## # bill_depth_mm_sd &lt;dbl&gt;, bill_depth_mm_n &lt;int&gt; "],["atogaki.html", "あとがき", " あとがき 本書の執筆にあたり、今回も同人誌制作の先輩である天川榎@EnokiAmakawa氏から背中押し＆多くの助言をいただきました。この場を借りてお礼申し上げます。 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
